{"_id":"next-mdx-remote","_rev":"70-6958a6c1e822fc92295cd9e13907bde4","name":"next-mdx-remote","dist-tags":{"latest":"5.0.0","canary":"0.0.0-canary-20240522052620","xdm":"2.1.4-xdm.0","next":"4.0.0-rc.2","mdx2":"4.0.0-alpha.2"},"versions":{"0.0.1":{"name":"next-mdx-remote","version":"0.0.1","description":"utilities for loading mdx from any remote source as data, rather than as a local import","main":"index.js","scripts":{"test":"jest"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"keywords":["next","next.js","mdx","markdown"],"author":{"name":"Jeff Escalante"},"license":"MPL-2.0","bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"gitHead":"c3e5a0bdd6e4ef3a1076fa5c1cfab453fada6c54","_id":"next-mdx-remote@0.0.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-4J4tDOOMKgLlzPUfuNcInZL2+JiLyoygV1WcMGLFasgmFQ0vYMBIYnVwVq4zrsKg4CVZ+oINrKJe/8rCrzptXg==","shasum":"f563b46933ea6826ce08dc4d29908adebb0000e2","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.1.tgz","fileCount":6,"unpackedSize":12569,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJepw5SCRA9TVsSAnZWagAAyv0P/jhZLIGIVsBR4AcXe/Lq\n8xO3SzVvB7s1Ov8z3PL6kOhAVgweKP89L2cA3lD2gjD7SVX5PbMUeTu/uOKI\ntuV1fUy0+9KFCbjbj5CMgw9fGzLfJsX6HwBRjt0/6B8pc9uAeWGIFtOIS+Q/\nFPLt9OWMhGz/viVaZPWZtx6hUnOM1YaECVOaVQ9mfvPJR6rQjbPL3a3Xtcy4\nRLJzY41ekQDaQIf2XKuDdLRy+s/NWPs/8geuLiCarRO+cEgTadbxkZVqagfV\n9IlaNz6LvrCshqjl6WbmAAPoxNqg2sXA0lncwMgaTiTBhH4QvCx7zamdh81Q\nr2KlquF59fr9MOH6Xsh61f0TSSMu6UBkv+xc9WkJ4CEUd2KVQNSbekU7LASo\nWgykKP9Y4vAkbZmHBMK+zQrulzjFWiRqk2JaDUmlSF0r7Io/aBJ9Npj65kxk\nHXU88dOQ0xiQObWZGtRfv0+vhdZOhz5CwCkV1kgDaNl4gnF0rlebu23gZCwK\npmsymW+GF4GC0DtrIEJIVJv3HzYTzpaj1dP+sVnyOr1qaeslR+7Mho9vPxEK\nThYJjnIoXbjnQYZPfVbTq+Fz1PJwDNNk4xmignO/BjBTmuUzuP+qOx+y/2OK\nfdRrHv0AY26a1DDFq3FUDk7hle8GLesmfaUqOdZue+3tb7bAmQBI/Db9RjCQ\n9Tc1\r\n=/zv6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCNgMZ14FSHAPLWVJIpw5U0oSRzAQzsNkR6yANhzSTN7wIgH89SmJYH6VPSvbnNWyPXgGhOEcliP9yfSwRDiBVxkas="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.1_1588006481509_0.9735590006005974"},"_hasShrinkwrap":false},"0.0.2":{"name":"next-mdx-remote","version":"0.0.2","description":"utilities for loading mdx from any remote source as data, rather than as a local import","main":"index.js","scripts":{"test":"jest"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"keywords":["next","next.js","mdx","markdown"],"author":{"name":"Jeff Escalante"},"license":"MPL-2.0","bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"gitHead":"ee34d943a09b2e69bafbaea214ffbfe848d80e53","_id":"next-mdx-remote@0.0.2","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-B5vIhYtH+Tr9wWXJx+feNobAofm4x5C43OtIsUjT2k0RAbNWtIBb74SLPGfkAn1AkiOgDtihNY3s7ivzNSd7tg==","shasum":"9ac635ea9b6b95dd310bf99798567fa81c83fd80","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.2.tgz","fileCount":6,"unpackedSize":12590,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJepydYCRA9TVsSAnZWagAAdE4P/iifFopCk17fSRSXargm\nsQw1MEIPVr2zcHztWqvanXKTYGSDqKb6Qq+Vx7UOWTSKM8UOlO2kZcqqSmIB\nMwe6Z51BhOlu3LisOdUom9IOv4YMoZOByoRYH9rhDv2o9wMQaVI5LZ5NTvwT\nXmgYlRKSK2rxa2mnTho39WUhfKpOROY3JNSeoWmBhEUj4iQa5Li+GM1Mr/6U\ngHGU9TL312H26ssn+d7XRwO1rvj82ELyge8RyxiPYHMjViPHjUjrJRFQKRzV\n8vrayyP5DhOSHjeo8kQ10ENxaUOU0dZpVqdzCZr+Ad3Xni3eRjSUteBedIgl\naYmePAF9oPnwQG4YUll5j6F+hNDqqscxPqb5f1/kfZKtcEwNpoBAhDhSRAFo\n9pvF6MPVX122spIazJv7SIlRD0atyo9u5kGvUiUQT0akB/cWLBO/SOhIudK7\naw8r9b3vG6GmqtfJC5pTIPXx4qr8iprYBkSJb4n7bO6dDWk6g/1IX4u5Gi34\n/2JaTt79o43fFWyQ5DAFNKf/BdRcAuxWIlEvBY8aYZs9060giPO4RhN8yJP0\nTRwwZnmhB2eWvr+fuFrsoX41+NkJ5xMQpwQaAbbXp/PhTsUFbw1sEFAuaa4g\nyWOa196oHTijcy6ls/wY713OhmQ9id1HcjEz3wcYQIGt3DZ2TEIKg/W8yIWf\nz4rj\r\n=hycw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE9Zwy86A6W3nis8Mp6M90gOBrgLt3HvNyljdxiDufeCAiEA4dBSGlykMwrlDAI3vEA+krNP8x1PJH1yXtCc2rDZCvg="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.2_1588012888391_0.9927538008307055"},"_hasShrinkwrap":false},"0.0.3":{"name":"next-mdx-remote","version":"0.0.3","description":"utilities for loading mdx from any remote source as data, rather than as a local import","main":"index.js","scripts":{"test":"jest"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"keywords":["next","next.js","mdx","markdown"],"author":{"name":"Jeff Escalante"},"license":"MPL-2.0","bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"gitHead":"e2c82093d9cb36bc25e964f22c6b55916808b84f","_id":"next-mdx-remote@0.0.3","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-X8HGf2a0nFgSmJj8RiSWEB2fAUk9H0MvrcSuNGTtxiXNEAzoKJpBIRugk3BYI4Jrg96oRbXWwk8C/0jLUjYRuw==","shasum":"e574d1aa56a87195930b3fa2d5b8e8f3a1edb1cd","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.3.tgz","fileCount":6,"unpackedSize":12599,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJepylLCRA9TVsSAnZWagAABlgP/R87YCvPnQlOJWK9dAkH\nU34k23+7U1P9oFjFUxIjIZczei96YfoIPoDw2iM9t8/FgSaGmI2OZESc8eOX\nILPtr64dqna6Nwl9EDKdVnPT4rd771gHox5IZLiYf3i70lj7k1YDnbFGCH1K\nvbL+ZscNjWysv1AN+REKAw+aQ94y0M2a60r5ZOCJ8liQhAt++tIWuYieWXbL\n4bcxSDLG8OfQYGgxEuhpeiAdJDIoXYu5/uSKrLSN0UJEBk8/kfSILNwNTKKj\nKJAlcHWTc1FYuC/OeJ2PnV7WWV+7LpJ98AXtQe2cpQrVihJ9IhMslGqayMWY\nUb5DZUiHKR1DcT5S007FYsihUaPFTV4XVwX8Wi7f2R72Lf5NPWvJWwKXzlcL\n3PlZMC5z0z23lpGliyyJv03TQROsAcByQiY/axLD40kG8mu101MlUoDfL0Ln\nKDAOlwg3C8MtWOOqvrLTVutdMOlVbIvGnQCF79ACLExtue8T9+B9xGiTUQKy\n9mjQu5i8oUsdUH/VFfffr2mpc65MJ348/nM6rTg9edTHHSkIpvIXdk5tIdbR\n5Kxk6sVHEAdyoTgUjfZQvYcqQnFzQo8n7q3hjgsTxbh/gx+Rav+y6MbeqJlD\nLYt2RZKi2VzwwdIUMJr7m9KT3QgISEVX0VAXATbG9kEFErj15cnOlF6s7c3V\nek2c\r\n=97Ut\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDC8hmrZWpgHDgcUEv+0pdGS13O4yoQnLJLR9gUKdAZgwIgc7zkPEB7fAvGwUsEUDsGx5AY5NFYKTyvjpx3HGdXXEo="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.3_1588013387211_0.04736181968993658"},"_hasShrinkwrap":false},"0.1.0":{"name":"next-mdx-remote","version":"0.1.0","description":"utilities for loading mdx from any remote source as data, rather than as a local import","main":"index.js","scripts":{"test":"jest"},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"keywords":["next","next.js","mdx","markdown"],"author":{"name":"Jeff Escalante"},"license":"MPL-2.0","bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"devDependencies":{"cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","jest":"^25.5.2","next":"^9.3.6","puppeteer":"^3.0.2","serve-handler":"^6.1.2"},"gitHead":"2d6273700827dbe3ae09070eac4175c46639eaa4","_id":"next-mdx-remote@0.1.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-ibwC5vb7gZKNzrCotQyqpcyprNpKCjN/SY7P3fgYJ4wxLiqep7d0iOtYEYnzK9OxuMvdrBImh9DC6+r0gkuq5g==","shasum":"3816d32366b0d4221b089fbdce488b50f01e8b12","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.1.0.tgz","fileCount":5,"unpackedSize":12912,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeqinDCRA9TVsSAnZWagAA338QAI4Xu3s14XrlH6yM6xEz\nYM2BxI5LmDl7G+ApnOiO7RpqltT8WWs8e+8uMNrv4ZC6sQ7T3DzCDxYiSZ70\n0r2fRxl1OlnsjuyYG/aK6ZMg9JL5gdUNMHbPSQ5GZU1GuK8DOFfA4lHUhbSB\nsi62JMOq7xAMMUGjUTiAb7wr8t1EOxv40g8W2g9XUZWvrE8s4qgObi84p2DH\nLdfpNtWg069oLwMemxXK9KVfW6/MNLTT7O3FNi9ozbZCVyFEkrpypSM06BPK\nQUfSd832sGB4UFOXkVqJDi9b4kKYWMaKqXYITgWN2t8NqHvZDpbhwYPgYDx6\nYEn3WTJkv/LnBUHhbME4JVfAhrQXzPwrA/gNYiLZvc+2j3GwOcWhTKqyDRBp\nD+rBYJ3p8cByaJ4tnUfh6PB0GbZNSkw1qKB4ZYof1o6IxFSWkBFciD8at0gR\nuY0RqQAdkJh1e55b/JRBerWWZESRH81bct/UCYUqhwFgq8/iBswwDomCz9ar\npReMjetLfvhUSxzNbREd8jtWpye4iDAwUsozuAXmmWNmQh+PcHjCvmhlt2NR\n9VPVMGCw5e5+ZiSKGNvEsG5T7PRLynnEdepMHNry6s/cpHA1E85XW4OS1iyz\neS3oAmyAerPMJZ5BJEE9/6tXxpQ21ZWJsTTb450C1DKgBWcvC6qErPXYQGDE\nNm5/\r\n=jetO\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDQf9JCPwo952m1y3l+x/v99de07i+Iy49EsjFs7RKr5QIhAIFWXE5tZE/XlPukpCCCp5rEJOJXHCF8bF3zvv/ZG3mp"}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.1.0_1588210114970_0.19938589275360585"},"_hasShrinkwrap":false},"0.1.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.1.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"devDependencies":{"cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","jest":"^25.5.2","next":"^9.3.6","puppeteer":"^3.0.2","serve-handler":"^6.1.2"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"test":"jest"},"sideEffects":false,"gitHead":"24927f1ef03a3e029691127a67b00de26baaf04f","_id":"next-mdx-remote@0.1.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-Vgmfy8JY1i7cDnIgdyvt9e6jJKTfqW+e6nZ5THUUJIyt1IZalRP3xfC38ZSzQ39hSOqKKxbLbp+W4Mstfk+mzw==","shasum":"e800edc2707c917c53abffcd8cc8c892555ec915","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.1.1.tgz","fileCount":5,"unpackedSize":12936,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJerHY8CRA9TVsSAnZWagAAu88P/jQ4sXYXBmMDPWp+/Xx3\nJ1YXjEu1/ug4D1woJqBPoiCHWitOTVeZFTxwggVyAq+i3gdOoaX1B4m2RDvn\nWYb2lOX1E4ihjHAgn117i1BUBaRixrOq5a4BYlz4mPpsxcekm3GqbplGSV7M\n+QBiwRBThjJOrns1hY25rH93AGPA0xOpw0VmuYTBIbBNL4gU+GlBalVrhous\nzUytDLbN/Dfb6nIKdTTJq9Jxo5WyElB+CKMQbM2rf4ZWDCumJyHE8R2rjyl8\nuC22KRv5opxDFOTDn93KkIOiro5T5uiawZCgcTtuX02WSZh7e1mJyX5tgPdQ\nizib5e+dm2w8xM2BOUfaByhYx7w+VEl+m5SiXREte/wFleuDIuLj8wghtllL\n1cqFABcyXDv89AcsBe3QKonI9AkG4TP7F9jpMQ76W3bR45QkxMv7lfnpimu0\nR+QNmAjQhp9lWt9EdMgwVdfbGUfcnwsY0gKal+YdOursGDaQHhNrMo426mkp\nAl/BosFEtoITeo/XO4J8pOeWWNBEJJWwyksGAdsv19s1x2c7QDFDq8kSbF8U\nmlFi9uB/mOkMMUkA2Ib+BbDqjdul3BfAE5GXZzxGB/i84lVjMCu2H3m/AKgp\nueyP77upOtHwARUdZOAGl7KefMgZaJufhXxp+rZtMq3KX22OzbvokJjfjlD2\njY6G\r\n=TUOg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIE36W2sfbMYMBEXkPtL5RjL0EejLm5+meX6Tn+um0khMAiB4x4M+Fh2g/1uckJrL5xbT31RgtA0RQJwrKqdZEoQu2w=="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.1.1_1588360763341_0.9551313183664716"},"_hasShrinkwrap":false},"0.3.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.3.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.9.0","@babel/preset-env":"^7.9.5","@mdx-js/mdx":"^1.5.9","@mdx-js/react":"^1.5.9","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"devDependencies":{"cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","jest":"^25.5.2","next":"^9.3.6","puppeteer":"^3.0.2","serve-handler":"^6.1.2"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"test":"jest"},"sideEffects":false,"gitHead":"9e3215fd252b6b66afd6d9601d59c06016375790","_id":"next-mdx-remote@0.3.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-Dq6kktodwyEVxfj/I3qsD51ZqqMjR7ifVCICOdO3zdkAkd+X9txqPhOiaSocIlBXYyK9vmDlxMporbEZk9azhA==","shasum":"3aa709695420e157bd1e7c497e31e8278fababc3","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.3.0.tgz","fileCount":5,"unpackedSize":12916,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJerJWgCRA9TVsSAnZWagAAI60P/ioDyYc1ZbM6nexaGlC4\nAPT8r5i9TtGn6UQuQyuSg5nVUOOIEzdfdQjqUByWri8NwGpgndeLUu0FgkJ/\nisTyWgH6Yv7YGfZQWOWUDwXSeqb7Kp8D2/hdJn2Ug3MTWSBJ7wgPM1tS8qGN\npELgoKeKN78Rvz969Lb6chQGhd1mgkyGa0Ka9iHt6hd6+bT5+Gn9rdxaCCBr\nXdGW+FrfldPE0i99k3wmqcWAwO+sGloejuNw2kUBvQ8yNpYg7Y7IgsulpGhy\nDaVRvwa1sAamST5k/EPqyq7V4SnQEinrVilNfWzxod1j1Ob1fVOZN4OV55xh\nohubuIcTpNU0fRp6xp/39lvQE7xDTq4jOsRmBf0MEwf2z0WiPZqK4bRficS8\n5PfPSwVs6GlJldpxoP7Iy5/84NZcnVE25oUF8qRaudD5yQEtWJrhKSHjIUr6\nJifgbd6yI6utmOWzLyTllpTybxKyD7DvRf3mkrLOrPIoPO0v0WFv0KIOKZE7\nBAHo0IPv72UXUbwrMTfT7GBPlErkzOwLAHlKgdOlAGlkElWV7p1edd/t+SQX\ntkOgSEzzlZoXMC9j0qzc2oXZgV5BsIYeqTVuWuA7BfsxmwfEOp+T3to+d7Ad\nQdvSTnrX1pVtVt9/zMpAlWDLrqdQ7oYKGyMyW2vvvayJQaG5B7KkqmxiZkcd\nD663\r\n=pm6X\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDsVsIXw0gVbXhid7ui01ad4JpeSd99lBiu1L5f7WgQ3wIhAJcT/ATV/eVQK8kR5FE8CWLF3GamYrPMf7rUdZ1OA1dZ"}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.3.0_1588368800557_0.06033822013567525"},"_hasShrinkwrap":false},"0.4.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.4.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.9.6","@babel/preset-env":"^7.9.6","@mdx-js/mdx":"^1.6.1","@mdx-js/react":"^1.6.1","react":"^16.13.1","react-dom":"^16.13.1","require-from-string":"^2.0.2"},"devDependencies":{"@hashicorp/remark-plugins":"^2.2.1","cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.0.1","next":"^9.4.1","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^3.1.0","release":"^6.1.0","rmfr":"^2.0.0","serve-handler":"^6.1.2"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","test":"jest","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish"},"sideEffects":false,"gitHead":"add9e8b5ec8382bb6b1b353813d251631e4415a9","_id":"next-mdx-remote@0.4.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-h1b3KNiXTUn8oEN9oyEbc/sAMiwgmXA/2/raaqtBVpUCqEYxQOYu1u7DhzwbEQq/WLuXMYHHhrjRuOARmaF0HA==","shasum":"ce7cf594ddd40a066f0855f5f997d0627684f05f","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.4.0.tgz","fileCount":5,"unpackedSize":13533,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJexuaZCRA9TVsSAnZWagAAspMP/jtD9qMZOygS6klplPi8\nIPI7xyAqsWBIfcVRD17fF1TMNPXlvq3bGBdaYg1zYLYopWUeWy/5ocRmc0UH\nQKT9EnZM7j75+P39OLol40z0ZMY+RWiM7ftKBtXz0wM/Uxi8RPJOXUC0wfAJ\nVLYDhkns7G5NyI8Cai7n1PjHDw7w1rVii3z8PB+m87L/EsZ4ipKNXG8BrTTQ\n+HtMp++2/tibkH091ntQS05aX2VDW/eBV/tG0Ly/U/AV6c2FiyhhzRd9cF6m\nsf7zz9zdEkbwMuSzkfGSIo7lnuG3E+BXG+5HbyjCFfv2zXX/p8lzHrVxzzjR\nsdhEUd/mq5Qg8CkI94zZR/yLT3PY+KCkaZJsUMSY5ERroG8wP1ErYkMf+TwW\nbsvYWi17St94DyS8W3aMgTpg4AwQHB3BMt7L9Pvtz0Q4hJ3SfnsWEBpWuBFm\nkpNjp4XwlrU5mNPmHIspwaOvkqXB/awFoOk4B19fugYstBehrLHU6WqLsomf\nNU3mgNKCB0OtknoJ+uQjhBHJVXeS5mYqMw392v+yw+PzqZJVSWIWgg8uBEBk\nIcDkqOEh7CUxjlo3g2vkKblHrTATzqHdzJy30/576m/sscmbO+ZX3aRFvxe7\nusPM1uBA/y7Y/ndy6mw4J6lZjDKisp+q8Z9CU0Sz/DX8JfcmaxA0+D4PNVh/\nNTAH\r\n=EFf0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDUsebehWix45h1AtnG3/H1SwdRowpvYVwHEW+QPW/f/QIhAI7SO6u9xkY1hRsz4qmRcMjx6QhXePeQPeUn0Bx4IVwg"}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.4.0_1590093464990_0.1786197276940067"},"_hasShrinkwrap":false},"0.5.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.5.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.9.6","@babel/preset-env":"^7.9.6","@mdx-js/mdx":"^1.6.1","@mdx-js/react":"^1.6.1","react":"^16.13.1","react-dom":"^16.13.1"},"devDependencies":{"@hashicorp/remark-plugins":"^2.2.1","cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.0.1","next":"^9.4.1","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^3.1.0","release":"^6.1.0","rmfr":"^2.0.0","serve-handler":"^6.1.2"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","test":"jest","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish"},"sideEffects":false,"gitHead":"4828f4ecd4d03e9d97152d3048cbecf6956e9750","_id":"next-mdx-remote@0.5.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-x6+a4TPCVZd3+k0JFJCFKLZkQIV7jKF/EGsxQOvpg7ShsKUIiiYOmorlBC4BTYTvIMHrUATtsYJ5Bn0+ybjX1Q==","shasum":"3135894c1d5e11ce719422f41a77825b11620793","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.5.0.tgz","fileCount":5,"unpackedSize":14369,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfB5nuCRA9TVsSAnZWagAARN8P/3qUOjIGAF/RTE8KFOi7\nbMIr/+Ej70UI8516zIRhJqdNltoxi/WkPxBIumdW/p3FmhsO+wX7otnQyKrV\nbuoWvsvFKPMptyy63ppL3UXfCz5dR7YL1jaapTjm6KDqhNe2diJbukye0+AT\noXJRaYF0GdfTEAdYUhtLySkpAqnUXF8Tb0hVFfjX+M/uIzfvW3PDpbzPn9M2\noX1Bmkr1veFho9GbvqaQnPF0IZPdPqEZBBL/IjJNZKrZI3lcQW/K8ExUqM6D\nhu37pJ9yzkN91ZQHmx50QQisTEBk/Pl4wlFLXWw6gUmPY9GcQKAYlqpxTjeX\n5aU4yq695AVplkLnt3jwtElZegQpTbQwlqnilf2sYVUFXvjlH1eW4yudkV4W\nPnCP+/gZNycTXACW5nkAh2yGviKnnxDUF+BlMw++dYO1n0Mr8IvcY/VeUnXX\n/aVfGfYWWyJYY7hHFZkAkxxjulEUwrH8eWTgH8oBPcTm8Phu6C/E6qyrHOrH\ntfXTD3fUAVDn2xRM1vLl0Vqd0IjFU3oCChQ2brJJuj4Wsu+gwca5Q+GAaZH7\nQIJfZcOX11dyEMSOgCWJG+s1LfPIV7gGz+Ids7g5ttAazThYnP6HFKJolWwN\nMmzr0l1CNxzeBnhSsWhVCUvB9dICgMfJb3m0/L9MT3U7RSOQa0+JVCifI3Z0\nfR5V\r\n=s9DT\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHFYgtI2LcTJA0jFV1zhXwJN6/60PwlcEHqCgSJRqVLBAiADdsNakByKm99BDT7/u8yNw9+C75aSpbjIbLvjIKD7ww=="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.5.0_1594333678467_0.9847692560886638"},"_hasShrinkwrap":false},"0.5.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.5.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.9.6","@babel/preset-env":"^7.9.6","@mdx-js/mdx":"^1.6.1","@mdx-js/react":"^1.6.1","react":"^16.13.1","react-dom":"^16.13.1"},"devDependencies":{"@hashicorp/remark-plugins":"^2.2.1","cross-spawn":"^7.0.2","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.0.1","next":"^9.4.1","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^3.1.0","release":"^6.1.0","rmfr":"^2.0.0","serve-handler":"^6.1.2"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","test":"jest","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish"},"sideEffects":false,"gitHead":"eb7a44a458500633d2528c5b927b736b686e7f2b","_id":"next-mdx-remote@0.5.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-g6woSOYzSRkp/Bw65ZGQdOagsFK0XWKjNDcL9MEYD3GXDXpTEf+ZJg4Ef9YCHgAkC1dFTXwCUkzuZ+z5KISMew==","shasum":"1d8b784906f713ff36979c39b6a1b721c822e6ff","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.5.1.tgz","fileCount":5,"unpackedSize":14384,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfEMoeCRA9TVsSAnZWagAAfQMQAJ3SoFUmIs1ohRyuCJPR\n3ROc9rFAi2uBMCLO9xvzBChB7rUup91b4Us89w8IegzESx7FiVAwV510Bo4R\nZgYxsuVW/1N39ITAgBsk0/ee5SpEqaKvQ0BGsDg1yqobYaqLT64QmxYv/K2h\nY6pmYmMpO/BSUVP5xvo/cJ/9FGPIfuxME7Rh48COgHG/Y5H0Jv5yn0Pv+Acw\n4TWB35iMZ7SNK0cLjwkmXJvs9MEgoifj4BCA2WqAWUFGw9C9FDXkslmgpDyW\nlB9NwiTVZBdwK7sKdsFGt8o5h9xhzbi4Wimhzp23kG/gNfPHqoAQwjCF3Er3\n40z8enV92ZesD38FP5HI8Fy0hw3Kj2Y4niA/GtAe271lpCTfnv6b9xNb4HC0\neYtCmQreMAVJDsmsq9Ng0OYsfWvICYK6qScDPeJLSqcO12UpCz1XtXVcRV3O\nimpAA2TKqvI6+dvLA9x85S0f0Pyo1BgN+jnnaWbq5GgW5kmeF4rj/J4ZuU1J\nflbOCw/SrGncH3OcC872B/gI4NfecOXziCOfG2GFYmZJNwwwoYRREhI6uK6I\n84FVR4r0PtKz3ohuNQQsVKvNCggkMGMBrC4OpMI19yLHnWiDnFyxSQS77gnz\nQiXrrVPm26b+SxIRZZNF4e7pt8EFV4GypOopo5TFVVyC0qwRIB5vLXZrEKI7\nbjjd\r\n=7id2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHfHDU+RDcnEKy5XCu93i6kD3SiCFCl/kSrj83jtKBDBAiEApnLoCKYNXL8Ba2kF7eo9ya92mWy+aat2O+hol8mGwbc="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.5.1_1594935838001_0.04852829485973986"},"_hasShrinkwrap":false},"0.6.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.6.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.10.5","@babel/preset-env":"^7.10.4","@mdx-js/mdx":"^1.6.8","@mdx-js/react":"^1.6.8","react":"^16.13.1","react-dom":"^16.13.1"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.1.0","next":"^9.4.4","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^5.1.0","release":"^6.1.0","rmfr":"^2.0.0","serve-handler":"^6.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","test":"jest","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish"},"sideEffects":false,"gitHead":"a995352cb7fbb64ce273321937119500e73a15f6","_id":"next-mdx-remote@0.6.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-+KUPeXTRuSiOs9LL1xiliknt52LAKVkb5InnxVM0ulepFuCn0FXyXYyCPHRicsnJG9D6kp70Hs5yV5Qg5L0ctg==","shasum":"91d53cd9681de383610bf2463ff48131dc3cc6d7","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.6.0.tgz","fileCount":6,"unpackedSize":14459,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfEd2tCRA9TVsSAnZWagAAB5gP/RXSaenIf6v0qMJMnAAW\nP1lvz/S20N0jW1D74WFAXVAwYqJHjqv1s6o6KXV2b6wOMkdn68vdl3/288MR\nHwYIn+Cq9pkIsX9uazqwnKYbJBpnCcv9X7YOXL4IUsuCH0kPcjzgrk+0aQ37\nod4O4whRj9UvkJnk4toCknl/XQvVZhk++JRtfKS8lxpWnqm6iGaD4c9B+YtO\nZVgcQSkkukLnyTvroiDJIrdqm9FZ6ScmonbqssHXq43w+9XJC2O8bsRvqI0s\nots+jbyE+U+i9Uf6BR9A0Lv8FfcUJ90QubGlnSrUPhXtEIpPsU610DNg9nRy\ndl7USE7vjF9dMrLYw0x76/5boiWQiF80VNNkIaPNY9NyvfxAajDW6OYueSdL\nemlOe8Kcb1NRtIE00VDeARmDTw814v2KLVMDoEM8qDe34qLNVYuHpeRoDW3h\nMbhWooqUbiyZ9zn+/zbvOVstRHe8NUH/VMjxUU8+aoKm3aKtU97biUB7gQhC\nhHA/SiAMbwFglicfC2uygpFwsRK2sSUYnhOgY+aAF2BrXkVSwPMsTeNQwW2t\nHZuPzBdKmPJnC2xn6oMRmz9Jo8sjlujiUXtbvU0vumAwoNvY8xaHIKrz3Eny\ngxRbRP+WywRJG1+C1pGDvpbNdestmpcTAZKj/y6pa/2GOCOeVrA8UFWWUpxM\nqcGT\r\n=hVH6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICbhnt3xuBbGhMJrV2j041nsiukx6ZVIjm0OEXlN+hcuAiEA7d12yvvISkxFe9ZQgo9JOd8UWvAwxSXESYtAQgm9IDo="}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.6.0_1595006381206_0.513568125112188"},"_hasShrinkwrap":false},"1.0.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"1.0.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.11.1","@babel/preset-env":"^7.11.0","@babel/preset-react":"^7.10.4","@mdx-js/mdx":"^1.6.16","@mdx-js/react":"^1.6.16"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.4.0","next":"^9.5.2","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^5.2.1","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","main":"index.js","peerDependencies":{"react":"^16.13.1","react-dom":"^16.13.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"gitHead":"15d8a23927a15905edc58ce56d0afedd00d68be1","_id":"next-mdx-remote@1.0.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.6","dist":{"integrity":"sha512-18QulBpZKCMRiDx1YTlCwKWu3HWHqw4dXDeTHrJK0s5cJPbMhITwFIxZRhtzGPPPI1OxbmcLB76OpnRafBxymg==","shasum":"b4b1480faa56bd7d907d6cf8c3ad1bf7e8ce06f9","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-1.0.0.tgz","fileCount":7,"unpackedSize":33412,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfPFiKCRA9TVsSAnZWagAAU/EP/1x+oQTHSdmj9icYhYA5\nzQWXufCjLUWfFsT8pugOs21stgI2lZZcvTzbaUabZRDuVg/uSwNVXTRPSdDO\nu+nJhWggPFEkAy0+JJueu406yAvKq7UcNI6Vd5oGOZYUX7AggYbUsYUaAq53\nT5Vo6F8UjAhkgTOgLLI3ClQBoniMI9xqJjOSP8tUv7P/wp19ZXQm+D99Rfnr\nbzXYyOWmNfetln5cxmOdHM4T+uFi4X9TBo3FdzPoEmHs0pL1v/xjpDJ0M//d\n3sZYSPpXBQQj56DZTwCDkNsTeuGNqNxQUmTnU3KfnyRwbGsfN5oaBHdvfkSI\nFlFctIzfzImCjrZJpNqls4CKCXMTW3/rOoYMATxbSnWN3pY1bn4s1SLWDRoJ\n/QYjWaJ503FvZw2KOcVmBb0xkPdyfiYTXr3Bi20dEECByYYKv5h15jZekU1a\nIePRe+Fpj1sKfLgLeZPW7YJQQCuX6RGwYwLhpXK1FFzelEO8Ne4EyykLYLba\nuB89kj8Jfsz/wmFRo9ZrDmHyPnEIiF44jW7vZlsuysYbuy0zHjLmtCS9EgIQ\nqajTAIVkzcHK7voGEVc421K61RvYN7OKUCCRjciHAlo58cACGo4uhi8XHzV/\ndh52SoN3pK8u1r5MdBk7ookUIiNh93r4wEhPx+SwWnOjEslzdhF9YQZN3XjM\nooKg\r\n=GY50\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD+tzKCzALTH+A2PTl8w8HgzttLeDjVpfpELmNWm2UYtAIhAONEI0P/gURrOoWkFN80/AA0s5yOSxu/MoBNMdin9lAV"}]},"maintainers":[{"name":"jescalan","email":"npm.je@mailhero.io"}],"_npmUser":{"name":"jescalan","email":"npm.je@mailhero.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_1.0.0_1597790345890_0.4245125522935784"},"_hasShrinkwrap":false},"1.0.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"1.0.1","author":{"name":"Jeff Escalante"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"dependencies":{"@babel/core":"^7.11.1","@babel/preset-env":"^7.11.0","@babel/preset-react":"^7.10.4","@mdx-js/mdx":"^1.6.16","@mdx-js/react":"^1.6.16"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.4.0","next":"^9.5.2","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^5.2.1","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3"},"peerDependencies":{"react":">=16.13.1 <17.0.1","react-dom":">=16.13.1 <17.0.1"},"husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"sideEffects":false,"license":"MPL-2.0","gitHead":"34e77486e6ff85046612ea7e78c71fdfe90c2a14","_id":"next-mdx-remote@1.0.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-95kUjs28F7yrjSt3Kex27yLZ5aP92L39YuJ973+nGyUjFMzyRFzliM/0oODcAHNbNGKe2pBuH+YB7Pq4o6mVEg==","shasum":"bb4d490aa6561bb08d2f778ba46cdb37a304019e","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-1.0.1.tgz","fileCount":8,"unpackedSize":64236,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfz+uICRA9TVsSAnZWagAAqbMP/3myoF7/lfgsyUXR9pLs\n3TqbQTXjkp8MNR9GnqKrRBW2amac2vtPF2THH7EzC5H0ZhRAWQJtHvyYzqIl\nlk8HcAp9V0A8GYYzL5lZTKwSP2eHMHgu+U0LmFWoZIXFLAmaDTBT6uieVScg\nJBgeIbVLZWYSrI3SpQxvvsATrN77oPG4m2OxZqnS7tOsyGovGyuPccKCsKcD\nnCvoOu7xuoaOhWmwPTj2nYGP1z4CaCmr23eXEayhEpJTtQL7i2+J18VUJDmo\nBpPgNuTrFIjtumnuNVgk0TA3r97AKDGNY6xvvk9h0GiwPq96wlms77G8B5Xy\nRW/dYAFy2gAd6zN9IiiLZThabGItJ3CYYi6KBS9s9dIGkr6+JUDtHWja6AKp\nxIHiGgxqtwzgJmWIj+bNuKFgr54bMPUOBDqiovYNsA8C6rDqEsANPDUAVafn\nPS7fa0Fiv6O3ifAJRjav7T4WsuMXLTlLrCjJ4jp66cL34bY7r1Hlh4qRdSdI\n9HyfCkD58YdJPh1XPlqEnP4SJHwhCB7lS64WlZM3X5Y65nypFWOKkBNeKdUH\nSxweb553IHMyqmc7/h9usGU3p9W7elkjMTlwVD3hUxW7bgSFz/jykQMZhSOG\n9IJYZbUDGZA/oRVtlq/7oN/Z27Mii/usFxtv6xD1cO/+UT+OqUSQdQbCGrzn\nPsxf\r\n=75nl\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE67eMsBPBgvRS2Hy0zzThfYgrVlh7L+aEVjX64FEHDzAiEAoG2L0PYdXALOh98X+NZNTBQdvGQR8a+7MB3PcsXq53Q="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_1.0.1_1607461767769_0.33232507253168175"},"_hasShrinkwrap":false},"1.0.1-canary.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"1.0.1-canary.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.11.1","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.10.4","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.16","@mdx-js/react":"^1.6.16"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.14","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.2.5","jest":"^26.4.0","next":"^9.5.5","prettier":"^2.0.5","pretty-quick":"^2.0.1","puppeteer":"^5.2.1","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <17.0.1","react-dom":">=16.13.1 <17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Example Usage](#example-usage)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Example Usage\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  const content = hydrate(source, { components })\n  return <div className=\"wrapper\">{content}</div>\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await renderToString(source, { components })\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `renderToString` will be removed from the browser bundle entirely.\n\n## APIs\n\nThis library exposes two functions, `renderToString` and `hydrate`, much like `react-dom`. These two are purposefully isolated into their own files -- `renderToString` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `hydrate` on the other hand is intended to be run on the client side, in the browser.\n\n- **`renderToString(source: string, { components?: object, mdxOptions?: object, scope?: object })`**\n\n  **`renderToString`** consumes a string of MDX along with any components it utilizes in the format `{ ComponentName: ActualComponent }`. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `hydrate` directly.\n\n  ```ts\n  renderToString(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // The `name` is how you will invoke the component in your MDX\n      components: { name: React.ComponentType },\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      scope: {},\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`hydrate(source: object, { components?: object })`**\n\n  **`hydrate`** consumes the output of `renderToString` as well as the same components argument as `renderToString`. Its result can be rendered directly into your component. This function will initially render static content, and hydrate it when the browser isn't busy with higher priority tasks.\n\n  ```ts\n  hydrate(\n    // The direct return value of `renderToString`\n    source,\n    // Should be the exact same components that were passed to `renderToString`\n    {\n      components: { name: React.ComponentType },\n    }\n  )\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      {content}\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await renderToString(content, { components, scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `renderToString`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n## Caveats\n\nThere's only one caveat here, which is that `import` cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided through the second argument to the `hydrate` and `renderToString` functions.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it hydrates the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `render-to-string` function to `hydrate`, as instructed in the documentation. **Do not pass user input into `hydrate`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize the `hydrate` function, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n### Usage Without Hydration\n\nIt's also worth noting that you do not _have_ to use `hydrate` on the client side â€” but without it, you will get a server-rendered result, meaning no ability to react to user input, etc. To do this, pass the `renderedOutput` prop of the object returned by `renderToString` to [`dangerouslySetInnerHTML`](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml):\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ renderedOutput }) {\n  return <div className=\"wrapper\" dangerouslySetInnerHTML={{ __html: renderedOutput }} />\n}\n\nexport async function getStaticProps() {\n  // <Test /> will be rendered to static markup, but will be non-interactive!\n  const source = 'Some **mdx** text, with a component <Test />'\n  const { renderedOutput } = await renderToString(source, { components })\n  return { props: { renderedOutput } }\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"f6a2640d49e8fa3ef37f8c6ad98c5fbd46d68c70","_id":"next-mdx-remote@1.0.1-canary.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.9","dist":{"integrity":"sha512-IkC5rusMBVgjiQ/fgzdHbtcE3lZqCd9/JyTP3R/MwxVMgRvTta2i9E30OETAmTf4gNN4z+D8RxiL0XI2WlmsDQ==","shasum":"78ac1c98e0e6398d958fd4a4555ec1d899d91ed8","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-1.0.1-canary.0.tgz","fileCount":12,"unpackedSize":67022,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf4rU3CRA9TVsSAnZWagAAieoP/A4xqsB2bVLnuXv6efGu\nqKt4BV9FVTHAjm8bYD2I2Y1uwT8AoLnHLkoxBxkda3EvmHwIMSDFFzEL65JM\nh7nyEn3DY+SOynr35AGlsxEzkHTN+r/HhHM8d2I/++Obk6kkEj9bg9AeDsHu\nZUUvb9lBCDqBXFdrAZJ7ssnS12xfklRkPV2nOY+ryksriUhDuR2c/8Eyzu3K\nNnc3FyBpkcsejUVuO+qxhmsIc9UbdclCrhtrq5+VrN9qvcSsSBiUtUNaVrVJ\nnK2DCcBpL83Q/eoWWb4KRxuXYbqFm7xv9X34ad5iuDaSx6dGZw5ImLtXEUOQ\n+MTEhN6ssyxdFipgm+2cMJATlfpSD1C3CdDDIPt634xYc7PeGm7dmN2ILgqJ\nmH3LFXnICV7akR1rqMXdPeXo64lamOES7spQQ8VN8ppnTNogVIQbbdFxYbYo\n1V7kCzVYpinosuSzN4/ape6j2qowCl8NtxaRSvlQg5LV/IdeAY9R32NEIMWP\nKxfewLTD1sNqWI+CcT4zaDPU6mrTufzCOO4RayRIfk7OWLas0mjUfbBSKbJ7\nPGqx9mtY7+GsZ24YCrSl1REaxRgRQiThEs78JK9vlDC3clCV7ZfSiHzUeJtQ\npW2p83PJUupCNw+HfsJCk+LO37UVuHJRqKpdtgVw/UXgFHv9FgjD2kLGcwMH\nzY3p\r\n=Jh7h\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIA5aMhSoxqfH0IUGtOe/PrHuMrTpo/JTVj2jI+S1x0s+AiEAqVSTvn9PFu/Y49gNMmX1jx3BePZFxx2R3aw9NkbU7pU="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_1.0.1-canary.0_1608693046953_0.3842005010501386"},"_hasShrinkwrap":false},"2.0.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.0.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <17.0.1","react-dom":">=16.13.1 <17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"5958c0583595176ab2b44dab227270e685d77925","_id":"next-mdx-remote@2.0.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.9","dist":{"integrity":"sha512-inIJWnmG+fek3vRaDGwar0K/wE7h8pL+HdKqDcjEImwACTZH7lo/PNRD/ukgYLQd1LDTgEnSWP+AlUkujdBUig==","shasum":"74237c8d23b2d48e3933626cdc69c1d743f67971","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.0.0.tgz","fileCount":12,"unpackedSize":68993,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf48VoCRA9TVsSAnZWagAAY8QQAI04vdpmzUCEcFtNXHbJ\nA0OM4r6Co6KpCOtws+v+eHVlf4HAEqKh7Y5rEt1VOln22EwBjFwKisR4hhX/\n5iw+fcnuzqppwTNSQhY0yyZ7AUYku7zG7KK8eoK5zPEBfK2zQqJ1T1sw2Yrh\nJEpXjTsB/OoQ7OPH1tb2mnHjbevazflB1a5eJPJHA+3jpBcA6QjY0XA97zZh\nwx1VzXEca7KPichQc7Snm05Rz5MTG7NSn+LWl9aAwFhcgNipubDsZnZd+dSM\nH/71wQlswW8nvvAyNmOSTAeEOC4oT2LFRIVshewTNSfexj4lkbKSx37VCxZp\nA7hlAWMbpNZFuhfXU8VebFQkcd56qmPrGD0wLbxfIeCJBiJP1EdqBw+wi3Al\nX+4vvo355vR8VkJNH+xnItSDNLWntwSfZB4PV9TbG94WISnJpZWz2Y2VnqgK\ncJ/HXVM0G6f1iUdqFyYCgYlYZnIljGori0ooECSmhfSQ0Nh3jv5Q2u+L+rh+\nhRZIYrEbEhVDyJobE0QUAyKyA5hyGxDuX48KoBv3SYcrE7l8gdlKapYgWCAm\n5y0MdFSsnpQaBBQNfLEb/cgjjs/QZuT/Fe32vGjljm2er1HHB921IBhRKkXJ\nfbuzpbjSrmZffcRPP2wRJXL/qIfXQDzku2fUcwFwNiQ/9P1GHp3HFqP49sIQ\nqlQQ\r\n=LvIl\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC1umhuzbWxdmeBKtdrVdAh2p/oGokB86kU6nhOGkjHcgIhAK16sUZwsczQtSWVZo/3oVsIFsk3KhuXH6NCWG045gb+"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.0.0_1608762727686_0.718264823396602"},"_hasShrinkwrap":false},"2.0.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.0.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <17.0.1","react-dom":">=16.13.1 <17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"797f471681e09496758ad338fe75c4827b65fde6","_id":"next-mdx-remote@2.0.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.9","dist":{"integrity":"sha512-UdSAsjxN0gcIf1IjvStmRjubNZq7tEVjiQmr2T1o04GS2ZtNuzhML5HQptQ4qcpenYG/y6SAMITRZiSRUnFuYA==","shasum":"ef344d2f4833a1b4a77efa224dde760a5566a4cc","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.0.1.tgz","fileCount":12,"unpackedSize":68995,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf6N+KCRA9TVsSAnZWagAA4gwP/1rtJ+bPBRYp8Gw++wjX\nBi1t+adYVPM31thworq9QHZ1710T1PutZf5YAvRNG09YxbOdZ9hT7dBS6utm\nExQDy/cqlprbMmaQwIfg9XLClS/5I5rAxQ7Cn/FIpiEq6qMtU+peplbZvLeA\nI4zI1V7gNsJgNHcLS+SGPD6Li+/Xew8Hew7vNaA5EkFsQp8bqJ99jJbRRpq6\nHXikxVqVf+fDzkjtBrXEPiTjaf3bwho2/OQE4SVo2so3CRNe+rN2jVeLY0PH\nvKUemgPO9baFL6kmFe5IKp2O4mZQzo4YhnpX86LQjO/k9Xlxgqri/pz3fAxj\nIitEdmkfEmqutblEMkyvebURep38UChZ6SBKh8jj3HLy2R4+Sc/91nNcESwP\nF3P2vjUg27oa5LpZU+Xe+KBfZueMFhfhlNNqGQuFw47LRazEWKXEhauPnoK9\na1njUTUBkPhfRhwIf4vo4O8IHO0g/7wkL30py6GzD90JgbWoJLPeIxxg/JMB\nT33c6F8WL+zkWUfQ19B9zLKIbl0hTdkB8tdccX/KWCqLQHcKXm2gAZAQ5CWK\nwYsGZlgXNetizW/w1rrzJM5dOwWsInEl3uEkJQN5TqWrcDB3mBdWzfCgJ4Mb\nvnQ1gMrMDQgehz8hXwRYR66O87KXZgUvin1mwI9SYOAa0PHaiBvS4k905yH9\nrBMm\r\n=pxm3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEjnoMU6gJ4WUTVppAhPLN9Kkz7MQjbUq7rjWNpgbplwAiAnS53Mbkc4G0dZm8wlBGbEHbCXmOBpmBivf5eoWN5Pmg=="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.0.1_1609097097868_0.8152537127054869"},"_hasShrinkwrap":false},"2.1.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <=17.0.1","react-dom":">=16.13.1 <=17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"221773ba52427b80ededbfbc60c46aa10454f13a","_id":"next-mdx-remote@2.1.0","_nodeVersion":"12.13.0","_npmVersion":"6.14.10","dist":{"integrity":"sha512-fCLkLEgnnFbQg+pIPHpwsHgftjGNNWFHTlijcI+jNve/5Et1t+z+V5tln3eF3nqeBMGUuXjodLs69+Cb2OrxMA==","shasum":"e3dc2d50f192d4c906ff2892d88531fd54da75d7","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.0.tgz","fileCount":12,"unpackedSize":72780,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf9hSuCRA9TVsSAnZWagAAqfAP/3oQzND6pmq8g6AsQ5X3\neKfa0Pvzg942oAJBNtvltZvsiApxuCwoV1X450SFwP6EhxdHiGK4SFuCQxYR\nbfy3nVNuOcQkgO97F6SdodwHGz2RlnTgw9Slwrw0s+PiavXnQ82LUMb849Ki\n2nyw2VVxTlMhnlgsoddVRSOSf+K7GAYnSJS2WYC/e70xcArwYH+xjV5RVJBU\nOGd3zDhKm68lGtRkKrU9PT/3TUvgenCvhk+6iuyd+ktAJS9K1l8SQH63966r\n6f5mSaqFvjRSCEeTsFWay37Dxbz1ftwrSA0rkN4D42nxFF/hZIjDFACRLLmN\nZ++9+IbUYgyqI/3dA3+lNcTn6N8J2c/X+U1civAj4EhE6Q7KmgJViariWLWM\nyUEOu9vgmjKAhwMm/XxToCZwMXBiQroLfgMsmr4fCNrJ0waLYsxFrDJI+emu\nqFqftSol8jWVEWqjEupua7+aSPuoXiOZUJ4lmKZeBR2zc3RdtRgdzouFWvaB\n8wBSwuguFWOM0f2mAat13F96P/Oopo2ROK1sM2VyQyPneR8V+/wJNQO+dnF4\nJUCj4UiSF2TUqDVc9JXsK0WLlORuR3GCwh2sfCtg1mdrDPPZY1vrbrSfaV8J\nMyjUViteZIPE7/c32OtYk9l9uXoAFaGQlCSZl8mmCuuMKouACL2nXrD4FvmN\n5Ztc\r\n=X1A3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGC0jZKgO5Iwpps9B6XHBDd2uPYM8ZHmqJ9AvAVWgzjYAiB5e/DZD1cf+mg+SczbYjAFq+NshLM+05oyHCQWTx17lQ=="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.0_1609962669591_0.972996313646008"},"_hasShrinkwrap":false},"2.1.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <=17.0.1","react-dom":">=16.13.1 <=17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"f8fa05e55634be29109d7019baef5604483004d4","_id":"next-mdx-remote@2.1.1","_nodeVersion":"12.13.0","_npmVersion":"6.14.10","dist":{"integrity":"sha512-GHskKRaMISTVyliXsexohgpNH1sDBDhON0JpXJFeWMcXn+2XPb2aHXK9OUEMb8vHkEq3cEsYIZ+t7lWHm8Eu6A==","shasum":"5a5152aa642ca94197ce7e0ea57d78ea4af111b8","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.1.tgz","fileCount":12,"unpackedSize":72728,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf93yLCRA9TVsSAnZWagAA600P/Apcbv5KRDN41d/hYBTU\nZYTxz2NtsM0WjnNp2W4i+FTl3Os1lJnD0D5G26LkwVoGNMtE5UyrziyVBhm/\nmUvzoILmd0KI2xoIrT4UnrLkWLPgqTvC3xP/rvIf1wbCbDj1x/Pivg0Z8cqo\nI8XkruOKRq7zNZaYejV+uBFNRgZaf0vnbhwUgnWDtGkJqLrkzlVJnSS7TeXw\nZqyrZLw4Al8QKh0tSs06AKIf020E9hh0Iu0qLAOXWWb6KDmBBQl/OLNCqhBP\ngXna6DcasG92wGGFH0IEEcPuTRB2ow38hkv7LMf1nUKgBJr9xEruSmpCaIDJ\nPK70lgoh4amhqoz3ZfUvqKNc6VtA1IRhX3xokz1S5WVYo5Mz6+G0nW97bPbt\negaJ9SF4YLzyy77tfyeotugK9w8HGNchnKcyAAKgdcYEEkkI7SvFh4Txk14i\njiNfB6xfmgxkuznMDK4yndxg2FWtAHic0uWSFoRkhvL2KKuJcNbEU1aYd/Jm\nZlWAcRt3kgFl3bXaoZIEGaMMQJQKz6wInj0f61ldGJSTe5cWuSaAT7vBf8gR\nykZJFxwaavQIPsfEURHQmo9ARitc8MqEuMUFrhKbz1WM06No6DUkQZAeDOf+\nBJprPIE9kRtgONBi7/2DYMdcUJAAWIDchjiXy5shlksoo1UZQEfh9kndASAG\nVKYX\r\n=kv8j\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH4RM2XOD+PVC6XEzxla5IcqHQ6GDO8Pflljc//OVIhsAiEArKo5ZYS2nJZVE0e16QceftfqE2EMHJwmhZ3PZl+prz4="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.1_1610054794368_0.8925619131836695"},"_hasShrinkwrap":false},"2.1.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <=17.0.1","react-dom":">=16.13.1 <=17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"875e56bff86d73d6f9e3fdc1235ccc767ea3a0e0","_id":"next-mdx-remote@2.1.2","_nodeVersion":"12.13.0","_npmVersion":"6.14.10","dist":{"integrity":"sha512-EHDjut1xWz/yQzF9MHMpfU4ZXt2OEpu11AFaNsItM0u+7T1LAmlkaoVCnNrKbVhhm0PBGGN7+cb4g6WNXYC7QQ==","shasum":"f17ee316c57610c0d83fbd6c6187aae415e528ed","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.2.tgz","fileCount":12,"unpackedSize":72740,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgCb+sCRA9TVsSAnZWagAAv9kQAKHZ2nGtarPJt3cpllQK\nM44F/dDx5ujMB/UNxV3cwPeJ3ta3H4Jf3x1V2v5WXkqg/G7ztZFr986Yl0D9\nFRUxJy4ZjcfYo5Oe6PNCqtCHBTD+n/d0MmCyYX15AGwVUuBjjbnz15gDkz1u\nkXMJ1IkB7kI8w+6kClSbnARvl1WnQyongADtNG84Zb8DODGwdsEOoSfM2PPI\naSf6gtQEiTqALK4Cw7xssd7tVaKt8wpl2aRTYlYLY2NGtUVqDZxrAa0nbZKz\nPyPMxzqi4xn5KHJ0DJ/K2ij61DeOKYRKKSyVkP94SmMfdgzmVXkxH+hx6D3h\n/B2O7EMX3fdev/vUbHax7hoqh9yb0sDwPUMkc4x6EQeoUnjCb3X1qE+z+t4m\nIFQjMnQGY8++DCMVnlazFraax8hXqJRMxLLdKbW5imOSpIUbwb8aAYqNjBAW\nOi9/5VOkMTRxznS2EELbqnm2sWTdgLkB5NbiqDqzZKtTMPLU8CnZCVY5mzXB\n3SXLNPQ47mH+SD5a8VIjX9F+5nGkjk9yWE+YwUXhXajVc5wKFVNRuwjEkGcs\nQC2x8fmCHqx3MHl80k1oCg6AP5YiFRa7Hyqo5KT02go08nubcsFQsZgy8fCv\nXqgZDYxBrNhIwap1Zco0yNIv4fHwUNUFCqqBbKG6f5KTyyqulDcXrzPVMw3Z\nC2Vc\r\n=+SJ4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDuVEeO6q/Lsv8uDtfiT2BRccPFJ9PSw41Lc5FyDsLhtgIhAMS6vwQ5Rc4d2/HkgfpjXJkKvb2HYuzwbXvpv13UD6c8"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.2_1611251628014_0.21627833215810432"},"_hasShrinkwrap":false},"2.1.3":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.3","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <=17.0.1","react-dom":">=16.13.1 <=17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"9a675ccf6d9e8b3dae9e4ee824f187b50e86ae15","_id":"next-mdx-remote@2.1.3","_nodeVersion":"12.13.0","_npmVersion":"6.14.10","dist":{"integrity":"sha512-wDI1KepnqG3FDu1wQJAJGGXAoyasjzbehcIhC+felDxGEbEEG8tYOkvMttXvMs4zaXPG4NeWnx0Ev0KdF0ZX1w==","shasum":"a427d690691af081384770b464d3803350ada41f","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.3.tgz","fileCount":12,"unpackedSize":72748,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgC1IQCRA9TVsSAnZWagAAf90P/1I8Sf/XkINyPdLmJz7S\n6KQ6kndIsFPSMkbGfdc70m+aCgmA9bkFM5Hia9U5SVy9SW/0I0lDDNFdZR8t\nQOv1I9W5DIH9vIzOjgf3n0hwHTbJjSKNBLWE6jWDV+M35J/oj5s48iYnSnTD\nNphS9BA2XzLOgW2/xcXGBOxOJXBCaztMwHbwvPYiDccPkhnx6j/kN/V0WDoF\n9SFrB1/llQ1LSHb8WW+P61/TPj5PhS0CMggwumY9SkEIkaj6Q7pSnIlcmgQb\nLcSUhQBxtbFvJMvEiwNnj4rr+0raXFfp30aP2pgD+GaJcwC5bce1ohjs5/UY\ni/EN5GVe58QTbUMIq+Bh0UyVTkXs4CQSxdFoPJaM6I4KJQF5Yh+LPJduvsRM\ngX2XUMm+pUk25VBgT+lYX3CIP6kA7cYR94rEjFJiJ8WKxpgxNbzR1515zGfg\nPSjPzsBrbzc+qBOr/4eSntUqMvumwNRfdMn99sVPjxNBmuPHcYKOTvrw5S3X\nlj3bUTDMvdZg2P64KKUmuDZ6CxuH/O4gNrSvnPq6WK29+osPgeWRpXH3tmBk\nM9tLJW9G4AAaaUTYVVQuqxf9xiYktbPol4JrBZ+Ny2vDG7yw46jxsKBwXCEK\nMkDOqk6yXGyxcthXNysT/NPLV9Eque/jQJircYMXG/CXUaph1VAcZmF9u24f\nxbBd\r\n=8/Fn\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCyfYfEtzLdA9VLMRnhHDnfvKI75VTNynImCypprkWESgIhAMX3I5wxGvQd+W1EXwEJUUaG1Vz2r2A4BDdl55oa42b8"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.3_1611354639790_0.7069922562167279"},"_hasShrinkwrap":false},"2.1.4-xdm.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.4-xdm.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","xdm":"^1.0.1"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-babel":"^5.3.0","@rollup/plugin-commonjs":"^17.1.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.0","@testing-library/react":"^11.2.5","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","jest-module-field-resolver":"0.0.1","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.0","react-dom":"^17.0.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.39.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"transform":{"^.+\\.(m?jsx?|tsx?)$":"babel-jest"},"transformIgnorePatterns":["node_modules/(?!(xdm|indexed-filter|append-type|estree-walker|periscopic)/)"],"testPathIgnorePatterns":["fixtures"],"verbose":true,"resolver":"jest-module-field-resolver"},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.13.1 <=17.0.1","react-dom":">=16.13.1 <=17.0.1"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","build":"rollup -c rollup.config.js","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Example Usage](#example-usage)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Example Usage\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  const content = hydrate(source, { components })\n  return <div className=\"wrapper\">{content}</div>\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await renderToString(source, { components })\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `renderToString` will be removed from the browser bundle entirely.\n\n## APIs\n\nThis library exposes two functions, `renderToString` and `hydrate`, much like `react-dom`. These two are purposefully isolated into their own files -- `renderToString` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `hydrate` on the other hand is intended to be run on the client side, in the browser.\n\n- **`renderToString(source: string, { components?: object, mdxOptions?: object, provider?: object, scope?: object })`**\n\n  **`renderToString`** consumes a string of MDX along with any components it utilizes in the format `{ ComponentName: ActualComponent }`. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `hydrate` directly.\n\n  ```ts\n  renderToString(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // The `name` is how you will invoke the component in your MDX\n      components?: { name: React.Component },\n      // wraps the given provider around the mdx content\n      provider?: { component: React.Component, props: Record<string, unknown> },\n      // made available to the arguments of any custom mdx component\n      scope?: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions?: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`hydrate(source: object, { components?: object, provider?: object })`**\n\n  **`hydrate`** consumes the output of `renderToString` as well as the same components argument as `renderToString`. Its result can be rendered directly into your component. This function will initially render static content, and hydrate it when the browser isn't busy with higher priority tasks.\n\n  ```ts\n  hydrate(\n    // The direct return value of `renderToString`\n    source,\n    // Should be the exact same components that were passed to `renderToString`\n    {\n      components: { name: React.ComponentType },\n      provider: { component: React.ComponentType, props: Record<string, unknown> },\n    }\n  )\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      {content}\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await renderToString(content, { components, scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `renderToString`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Using Providers\n\nIf any of the components in your MDX file require access to the values from a provider, you need special handling for this. Remember, this library treats your mdx content as _data provided to your page_, not as a page itself, so providers in your normal scope will not naturally wrap its results.\n\nLet's look at an example of using an auth0 provider, so that you could potentially customize some of your mdx components to the user viewing them.\n\n```jsx\nimport { Auth0Provider } from '@auth0/auth0-react'\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\nimport Test from '../components/test'\n\nconst components = { Test }\n\n// here, we build a provider config object\nconst provider = {\n  component: Auth0Provider,\n  props: { domain: 'example.com', clientId: 'xxx', redirectUri: 'xxx' },\n}\n\nexport default function TestPage({ source }) {\n  const content = hydrate(source, { components, provider }) // <- add the provider here\n  return <div className=\"wrapper\">{content}</div>\n}\n\nexport async function getStaticProps() {\n  // mdx text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await renderToString(source, { components, provider }) // <- add it here as well\n  return { props: { source: mdxSource } }\n}\n```\n\nThat's it! The provider will be wrapped around your MDX page when hydrated and you will be able to be able to access any of its values from within your components. For an example using a custom provider, check out the test suite.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\nThere's only one caveat here, which is that `import` cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided through the second argument to the `hydrate` and `renderToString` functions.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it hydrates the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `render-to-string` function to `hydrate`, as instructed in the documentation. **Do not pass user input into `hydrate`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize the `hydrate` function, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n### Usage Without Hydration\n\nIt's also worth noting that you do not _have_ to use `hydrate` on the client side â€” but without it, you will get a server-rendered result, meaning no ability to react to user input, etc. To do this, pass the `renderedOutput` prop of the object returned by `renderToString` to [`dangerouslySetInnerHTML`](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml):\n\n```jsx\nimport renderToString from 'next-mdx-remote/render-to-string'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ renderedOutput }) {\n  return (\n    <div\n      className=\"wrapper\"\n      dangerouslySetInnerHTML={{ __html: renderedOutput }}\n    />\n  )\n}\n\nexport async function getStaticProps() {\n  // <Test /> will be rendered to static markup, but will be non-interactive!\n  const source = 'Some **mdx** text, with a component <Test />'\n  const { renderedOutput } = await renderToString(source, { components })\n  return { props: { renderedOutput } }\n}\n```\n\n## Typescript\n\nThis project does include native types for typescript use. Both `renderToString` and `hydrate` have types normally as you'd expect, and the library also offers exports of two types that are shared between the two functions and that you may need to include in your own files. Both types can be imported from `next-mdx-remote/types` and are namespaced under `MdxRemote`. The two types are as follows:\n\n- `MdxRemote.Components` - represents the type of the \"components\" object referenced in the docs above, which needs to be passed to both `hydrate` and `renderToString`\n- `MdxRemote.Source` - represents the type of the return value of `renderToString`, which also must be passed into `hydrate.\n\nBelow is an example of a simple implementation in typescript. You may not need to implement the types exactly in this way for every configuration of typescript - this example is just a demonstration of where the types could be applied if needed.\n\n```ts\nimport renderToString from 'next-mdx-remote/render-to-string'\nimport hydrate from 'next-mdx-remote/hydrate'\nimport { MdxRemote } from 'next-mdx-remote/types'\nimport ExampleComponent from './example'\n\nconst components: MdxRemote.Components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MdxRemote.Source\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  const content = hydrate(mdxSource, { components })\n  return <div>{content}</div>\n}\n\nexport async function getStaticProps() {\n  const mdxSource = await renderToString(\n    'some *mdx* content: <ExampleComponent />',\n    { components }\n  )\n  return { props: { mdxSource } }\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"c00cbf79ff4852158f781b9e48bca9c36ecb4f0a","_id":"next-mdx-remote@2.1.4-xdm.0","_nodeVersion":"14.15.3","_npmVersion":"6.14.11","dist":{"integrity":"sha512-Lak2tW1C9yXqseSaKPhyLvqoQdiLxP0pTLL99DGuViWEpaEGrV0UOBWo4xtuLOx32osgoVEAl9Bu+DP1xizQVw==","shasum":"2eae570a09ab7f66801ae120135bde2448f15502","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.4-xdm.0.tgz","fileCount":18,"unpackedSize":1042890,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgLXlbCRA9TVsSAnZWagAA8UcP/3U/9k64udPy6rOXdVxb\n5vzCVzWLsDboK2G/OWwxEqP7YseiyU2b2K+lJ875arpt7UodhHJhEg+JhExe\n5T/IewZ5rZbJy938TsrIH9UxFd40dODGBwBI3w5sj3fOXd7O0VwYuhlFBEUn\n0L3N58fzyWHpipJ+zXP/rBWxkzX5g+KFPocifETpVG494PnPioWBgMa0eQZo\nhQxt23/WNuMZGgr7Z3n9HNSIk4pEexQqOHLycfLS+OTo2BoeiMwqSS5UgW4X\n60yMp8MsPHhKBkn6jhjEbMbeLW1r30+CHKRq6FzqK4idppJZ3d1K4Qa6FMWw\ns2rQ21HSoTLr2VJEaRpiH9q4+18ygomOt5/9sW1W7n5zZVxV8qI/3fi7QwiM\nTadceae1EdPmdcmNhUbp0YFTJptSm932uKlXg5gId4W/4Dxfy6ln1NQABTTI\njFnouNTioXcFsZMUO5QViePvmIxGRsCf1IBTdGL+jlG4O+v7nlJda87oAH89\ni0OnlU2awPxCG6tZTKGW3ME+Qfs2fir40Cc9TQTXF+erBl5Y90P7sNodTnKv\nasxyZsh/n0BvYVS265DasRLoEHVNH+ycxrgYp2G/hQ1bjFABV2o2YOd8JB6N\nMrFMDP5q1AkyESoEBqALpoJbw5AETO9FH8BLc6A+LD+HReq/c7754/GJs+hq\n+6fb\r\n=h/+e\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC5G1RCksZUveGwPimp2/exl6rtGS9brok9R4qdd5IjcgIhAIeodUV1fKnkq2d+3iHY+LBErV9UEH9q96EJ82fNX1u+"}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.4-xdm.0_1613592922948_0.7171743618948685"},"_hasShrinkwrap":false},"2.1.4":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"2.1.4","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@babel/core":"^7.12.10","@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22"},"devDependencies":{"@hashicorp/remark-plugins":"^3.0.0","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","typescript":"^4.1.3"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"b82c737a423bb71279164e4a08ec9be9d562ea16","_id":"next-mdx-remote@2.1.4","_nodeVersion":"14.15.4","_npmVersion":"7.8.0","dist":{"integrity":"sha512-HHJasFVgPGjWXW3tWC37NCvHcQUOjJgVUMdwxgVbshwgtDLrGmupNkist/iamDLlvVibU52B9rqM9VAWofq7cA==","shasum":"21b2a72bdc9a172f09c1e6e80fc9d79ee480fa51","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-2.1.4.tgz","fileCount":13,"unpackedSize":73732,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgdLPKCRA9TVsSAnZWagAAtVgP/j+lNSTaxKCQXuo/h2nR\nNnDC80lqtdZ6IUFLqHZFgsmOExFPqbye1g4htZYFHxXL2vzoIuWK9tqeyrfv\nF98wCQGUwWv5oAAUJH/XY193yH1P0JDQd977ldhJsIqfHEdcut7WVGvZE0bq\n3UD/6rK92EbJic7AAQ5UY7eGmCtsFZYBYFiM4KrclGaeKmrYvjyBNX9qUU7a\noyq8zqERJToQg/8GeBF33AHF4FmYE8vpgKlNYkHM70Gx3Y1LWzXo2CbAMJ5/\ni9T4danfRRIRrTz8m4pncYO1C+NLtosLeJ52UrK1nT6i7FhvetBV4kjj5Oyk\nTtPxucBd1EoSsBEPjLChWj1HFc88S32uXyCcuINyWz/JChfZIvIjEyU0snfe\nlsakO9+apFLrPV2zHqX2TmLBYH22TA0ScoBXvz2KArYxPazdRaa1mqHUHlxp\n0PrOxhujH5P5X5adQfzBTVEJEjFFpLZN/v/BpoEeylhSn0K/9Qxg92whNYGH\nmkF2+XODXIqpLp20/JD7HCmL3f5wIAwQnvuxd0IalnmNv1GI+2rFBX1gTuxQ\npFsLmKxnJFNLokNAbA+JrPTruo3kvqQcxSydx0PnRW5Oq6ZPerU9LuKXRh8s\nbvCevl8cxGgcaCcB9yZsgwofIe5epXLB1EglwersvQRtASFTeqU2ZcH8Gs4j\n6uFf\r\n=sufg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCzw3yjdGBtxncpesEcs+22VWLdxahyCBr3gz6Zedln5QIhANC3agERpGafPKVENHna6GNWg1ocZG0fu33zgGa/4GtI"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_2.1.4_1618260937994_0.5041301107725855"},"_hasShrinkwrap":false},"3.0.0-alpha.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.0-alpha.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-babel":"^5.3.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.0","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","express":"^4.17.1","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"^9.5.5","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^16.13.1","react-dom":"^16.13.1","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Examples](#examples)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [TypeScript](#typescript)\n- [Migrating to v3](#migrating-to-v3)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data (component)</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing custom data (serialize)</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\nThere's only one caveat here, which is that `import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerialize<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport serialize from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerialize } from 'next-mdx-remote/mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerialize\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerialize> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating to v3\n\nAs of v3, usage of `next-mdx-remote` is slightly different. `renderToString` has been replaced with `serialize`, and `hydrate` has been removed in favor of the `<MDXRemote />` component.\n\nUnder the hood, v3 is more efficient and we've fixed a number of long-standing caveats with the way it was implemented. Most users should notice improved performance across the board!\n\nHere's what the diff looks like to migrate a simple implementation:\n\n```diff\n- import renderToString from 'next-mdx-remote/render-to-string'\n+ import { serialize } from 'next-mdx-remote/serialize'\n- import hydrate from 'next-mdx-remote/hydrate'\n+ import { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n-  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n-      {content}\n+      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n-  const mdxSource = await renderToString(source, { components })\n+  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n### Context\n\nContext usage and providers will now work without any additional configuration. Any contexts which are rendered higher up in the tree should be available for use within your rendered MDX. This should also fix a number of SSR-related CSS-in-JS bugs users were experiencing.\n\n### Content Hydration\n\nBy default, `<MDXRemote />` will now hydrate immediately. If you wish to retain the lazy hydration behavior, pass the `lazy` prop:\n\n```jsx\n<MDXRemote {...source} lazy />\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"65664fdc2d57f8ec3c2b247ed36b254d3b63e4ac","_id":"next-mdx-remote@3.0.0-alpha.0","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-Qp5VJjKyGo/W83MvCTNWreZEAt7fHLVHmALrNJyBlWGe4ueWaERXGlCKM88glY5zK2Ii9sPVNcTO7G3Y1VdTVA==","shasum":"18126393ce3d12e31bd3d25e6f5c5b33633d42cb","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.0-alpha.0.tgz","fileCount":16,"unpackedSize":82972,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJggy/XCRA9TVsSAnZWagAAQKQP/A6S1GGIgw7LSwXotboJ\now++M9y6tNJq8DLN33HI04GYq2JsG4FG7HFck5a8qFNVL+7ETpsI6XOV4dld\ngEjHKdhaYDBWk6oYRSVjod932lrSERLo9PD/m2VOLiJTcDcXTovQJ868KU2N\nTOeR9gn9K4YgFByq+egnBO8xM72OqZ94XbGo7xF5yyv/Rv0tSQtKV6Sl+p9o\nZahOosOBRKuidwFPcjka9dyT2LHAR0xZguJITUoPuk8aliaMHFv0Hrtr27ER\nDwFDTftnpgN6OP+w9HSrbsfU1FznpDVMO7jxkguukbABiqtT/GNRE/r9Gh1T\nzn6Dg2+84pq7lSB4RZAIm2YT9bxf4kqtYul3Ue3bYNjUqv1+2mQ4Hjs02SSr\ntDUF1os7AbBoybWQN9ES5NMMgwkTrdALEpcd4mmvHe4y1jKPVMMXiEQfLU3j\ngCmrOlSAndXtjs6qyXdek1OsoIwK19VhhDkjOz5KFha4AV52xUORWP6WPbKS\n71aIJlF1uD8zSahU1i8PFFPwHpuYOMLbfcegIHQ8YxxfMgFmVFN2ztFMSwRs\nclY3PGAlQyLpPmsURUkRyow2ufgHAKZovw8g2Wm0/UpjcohOuCOnnLOXAXzp\n3YW/IWrqZvyhx7SNz5Iac+F22S4JwcvR68XOIc8NZLEwOjbsWibN1pLa6isS\noqOx\r\n=FfFn\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDiGY9lWPnQfXUzzU/hK30H/iVOcqPUJQcDyg/46PharwIgUS60Yy2b8I3AXt1+bxOIlDYEdgK+vj/BFzaFKmrLAg8="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.0-alpha.0_1619210198672_0.1898126631272301"},"_hasShrinkwrap":false},"3.0.0-alpha.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.0-alpha.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.1.3","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Examples](#examples)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [TypeScript](#typescript)\n- [Migrating to v3](#migrating-to-v3)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data (component)</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing custom data (serialize)</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. If you need to pass custom scope that is not just an object, pass `scope` directly to `<MDXRemote />` where it's rendered.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\nThere's only one caveat here, which is that `import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport serialize from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating to v3\n\nAs of v3, usage of `next-mdx-remote` is slightly different. `renderToString` has been replaced with `serialize`, and `hydrate` has been removed in favor of the `<MDXRemote />` component.\n\nUnder the hood, v3 is more efficient and we've fixed a number of long-standing caveats with the way it was implemented. Most users should notice improved performance across the board!\n\nHere's what the diff looks like to migrate a simple implementation:\n\n```diff\n- import renderToString from 'next-mdx-remote/render-to-string'\n+ import { serialize } from 'next-mdx-remote/serialize'\n- import hydrate from 'next-mdx-remote/hydrate'\n+ import { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n-  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n-      {content}\n+      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n-  const mdxSource = await renderToString(source, { components })\n+  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n### Context\n\nContext usage and providers will now work without any additional configuration. Any contexts which are rendered higher up in the tree should be available for use within your rendered MDX. This should also fix a number of SSR-related CSS-in-JS bugs users were experiencing.\n\n### Content Hydration\n\nBy default, `<MDXRemote />` will now hydrate immediately. If you wish to retain the lazy hydration behavior, pass the `lazy` prop:\n\n```jsx\n<MDXRemote {...source} lazy />\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"c656626d12e29e149f04c3045d5908ad6e2928f3","_id":"next-mdx-remote@3.0.0-alpha.1","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-r6cL7GfbjYfiGFBdr3JPk9wOPRM+rFmFwCUj4QTA8LKF6KhLSAP/d1+8mvy6nx+IePWkdatPRCPjxf59DAo3Dg==","shasum":"5a18daa234ae3bc2f3ca6cdc358f3c3aa6baa348","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.0-alpha.1.tgz","fileCount":16,"unpackedSize":84079,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgiYQyCRA9TVsSAnZWagAAvCoQAJIUBJvWICr6m68iW8vT\nFAPgmv8gT77GVGdqsLAbN9eG6aGaVrKNwVX8EwdmU3yl8VSDhA1MPuUt/7y9\n7XkE+N34YBkuyqHde0U/SBrnbGRPBvqwSLp/ccH5Vu21LGSjM0NJlczmrS4L\nU0t2c59hMEV8ox+Ax4+nOzM5214Qfji1HAY4nNHLBDsHQbN61Q6L+B+XHruS\n2mXP7d6c0Cg8ARkitk+5EUUCBbCYjX3D3g+Ed5RB+PVjmFnc6ZrJUU1nCIcq\n5NXJ7eQc9lILxHWQgUgsPFl5D+1mYWB8dCtpmUnHBe1UzkntgpljnDnRBGix\nbV5vsEwRK8JMSrvlW9XFtx3Tctm0qjMio3RSLDCoAG6BlOTscC5Atn4+0lVA\npVD/J3ZWvcw1K9aY9Jr+4qhkrmGTXxsw1BfC05cfLAd1VpIMDf3zgXv+PjS5\nHn3hCFNOcK9cAyBnWXuo6TfrxEB6ujDM+2CpQy2tA7FTT54Sph4VfnhyGllL\nx+9T+hzI8+CpehybdkJrG78ClJ2PLPwh/XeQPGBqsOGsnSNBNhFfWw5k6eAu\nHwm8Q3+8heek2vhAenilj8uXnJ1AvUXOaB7CgVpyHtHp1e2jySErG8P97x4S\n6d/+2Lwb5g8FCN4cXUceKW060yZt9qgDKOAgteJGXL2ep2Zcc3FhLeoVOYi+\nGrBx\r\n=3LNc\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCYYy4w6ryCH2c6nndM16NrOepTYKisUfsIejIRBvq6xgIgTHMSW/8WKdDJ58bhTyrxw+TPjV7V9eJF/YxQzEPPThU="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.0-alpha.1_1619625009496_0.5028252675670475"},"_hasShrinkwrap":false},"3.0.0-alpha.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.0-alpha.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.1.3","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Examples](#examples)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [TypeScript](#typescript)\n- [Migrating to v3](#migrating-to-v3)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data (component)</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing custom data (serialize)</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. If you need to pass custom scope that is not just an object, pass `scope` directly to `<MDXRemote />` where it's rendered.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\nThere's only one caveat here, which is that `import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport serialize from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating to v3\n\nAs of v3, usage of `next-mdx-remote` is slightly different. `renderToString` has been replaced with `serialize`, and `hydrate` has been removed in favor of the `<MDXRemote />` component.\n\nUnder the hood, v3 is more efficient and we've fixed a number of long-standing caveats with the way it was implemented. Most users should notice improved performance across the board!\n\nHere's what the diff looks like to migrate a simple implementation:\n\n```diff\n- import renderToString from 'next-mdx-remote/render-to-string'\n+ import { serialize } from 'next-mdx-remote/serialize'\n- import hydrate from 'next-mdx-remote/hydrate'\n+ import { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n-  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n-      {content}\n+      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n-  const mdxSource = await renderToString(source, { components })\n+  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n### Context\n\nContext usage and providers will now work without any additional configuration. Any contexts which are rendered higher up in the tree should be available for use within your rendered MDX. This should also fix a number of SSR-related CSS-in-JS bugs users were experiencing.\n\n### Content Hydration\n\nBy default, `<MDXRemote />` will now hydrate immediately. If you wish to retain the lazy hydration behavior, pass the `lazy` prop:\n\n```jsx\n<MDXRemote {...source} lazy />\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"94919380ea42878d4f77a607d13191337f507c88","_id":"next-mdx-remote@3.0.0-alpha.2","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-5LG3vcXNXioY6gzeARiIJuqGwuAPEDPSxE+45kxplAmksbILR7YwKNFJx3DDExtoe2WEgKarMB6YRaeZh8mcRQ==","shasum":"7fdcd17d986628b4d1138d34fb862264ba83e3ff","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.0-alpha.2.tgz","fileCount":15,"unpackedSize":83996,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgkBbNCRA9TVsSAnZWagAAGtsQAI/TifYe5WOzyjhcpZRX\nse0Cx+S0J/jQW7qRaWp9C7m7U5KGKHitNM8HB6EZqZYNz7ZViyRYqtJnmXiC\nu/3hOqQI1IjSZ//XcKSmLYwO7qa3+9nQX4etmwRAZh74qZiglPVCUnp0CmNe\n6a6/GCS1c5wf9DEVKaqS4uuermZPSi5EWy2yW6CWynNW2NbJ8QbrCZCrEgGL\nGbjpYBSbYAyDgrJdcjnveG1HMeSjHbYQh9riZ3i1EsRV/o1hGKjL7I8N9ho0\n3gTJ1sqVUIMX//4a62A+brYw7HAOpF7v0ZAXcBOfHFwcN0nZBgeK2QmQ7r7S\ng8vcQ19lhB560iaump9C2G0mSGUr80iXoWdDRsfXXeaE33KvzMklR6jdICUI\nsdZzUQwOqPrBJjCwmuJTUjKsdSb6pAE+DjsXbaiho85voQVnCLFHFiNG9VQh\nXNS7/FsjJeJW27279FyElIJUWpF4ZXJk1xR6euYL80Z22IvC/epfxisS+e00\nXdb1SAyie73tb6ZI+GDQsNr0daO0/PzNiHvZVrGAwzHXDWp2fbiJCX2hM3GK\nFhhTf2T8dmyVJsFhPf5NrJKMyl524BHDI67hJCJywbxHi3ZAL25G1kTqs7DZ\nvi2Om0mx8B/mEW2PTG7yxFmsD4RyTm9SOowxQrUBMweaakyoUYP9SGZ9hfFv\nWcD/\r\n=kl+i\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDrpG1ti5PgQmFYeYGLb7yCoeCpBODpt+Tf4jJnANvQAAiEA7Mv5h/GrP8qjShPFAwmROh3hv/Pu2mVUoAtVprOZJe0="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.0-alpha.2_1620055757127_0.7298204376480635"},"_hasShrinkwrap":false},"3.0.0-alpha.3":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.0-alpha.3","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.1.3","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Examples](#examples)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [TypeScript](#typescript)\n- [Migrating to v3](#migrating-to-v3)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data (component)</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing custom data (serialize)</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. If you need to pass custom scope that is not just an object, pass `scope` directly to `<MDXRemote />` where it's rendered.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, target?: string | string[] })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Specify the target environment for the generated code. See esbuild docs:\n      // https://esbuild.github.io/api/#target\n      target: ['esnext'],\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\n#### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX, is transformed to support: `>= node 12, es2020`.\n\n#### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport serialize from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating to v3\n\nAs of v3, usage of `next-mdx-remote` is slightly different. `renderToString` has been replaced with `serialize`, and `hydrate` has been removed in favor of the `<MDXRemote />` component.\n\nUnder the hood, v3 is more efficient and we've fixed a number of long-standing caveats with the way it was implemented. Most users should notice improved performance across the board!\n\nHere's what the diff looks like to migrate a simple implementation:\n\n```diff\n- import renderToString from 'next-mdx-remote/render-to-string'\n+ import { serialize } from 'next-mdx-remote/serialize'\n- import hydrate from 'next-mdx-remote/hydrate'\n+ import { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n-  const content = hydrate(source, { components })\n  return (\n    <div className=\"wrapper\">\n-      {content}\n+      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n-  const mdxSource = await renderToString(source, { components })\n+  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n### Context\n\nContext usage and providers will now work without any additional configuration. Any contexts which are rendered higher up in the tree should be available for use within your rendered MDX. This should also fix a number of SSR-related CSS-in-JS bugs users were experiencing.\n\n### Content Hydration\n\nBy default, `<MDXRemote />` will now hydrate immediately. If you wish to retain the lazy hydration behavior, pass the `lazy` prop:\n\n```jsx\n<MDXRemote {...source} lazy />\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"55d2e619eea972c9ee8eab373760f4034597b1b5","_id":"next-mdx-remote@3.0.0-alpha.3","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-wSlzmBivm0mTxKG2Jumk91CCgoO2EZhYU2qlNUeMGk1Gz4R4D15ZOzaJc1DoQK1X3PpegC2VZgQaHl2fe8Q1xQ==","shasum":"01649c58bd1788aba47ec402732d62bdebfda972","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.0-alpha.3.tgz","fileCount":15,"unpackedSize":84603,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgkF2bCRA9TVsSAnZWagAAnOcP/08sBsHJIR+8auAdfpIT\nsQsCIXtF2PEiFrpjxVc4w3ALPv/kBIJxP9VvQlaG33RLv8sjQcjJ0HjtLQEW\nfO9LPc3PfMvzZxlqw3WoeTgHvJoeY0WbsStn17T+Tz6J12L5/mXPHe9m909x\nOVsihOEM00tfpVfIfbv7Jz8BMShhBMBuvXpkGGjvJUShCPJl+SpfDH2zqi4S\n38hxB2zwVEEbdmPaRNSD6KInNwd9Okzks2yq/U0rH/a2ECfxIRk5x8a3zSuD\nzbkfke02tRKG0jK9hn/bW2/59AwpJ+E2AVJHglmJ2npq1j3qPc+Fc4YrC+RU\ntplHvvhGNusqVz4/QXF2/UtVMB2nQQyNAVil60f52BfFptRW09Pd7IT17KdM\neDTWdpTebX7D1D9gADdVBwKYNIYpxD4betbJ8JUVYWgka2+v8slTjzEiWmD3\nR3DCAapYkcdkvp5Y9G+UVEEsn0CgUEdmY90AqYo55E7MYanhgr/bvBsmk/l1\nmfPr5PWAyDE7xtJePDSmaB1zmQEvlAN8CAQgwlLBoSudzSyxYpzqY2EZ9Wbc\nByyf0EUrp41cNawJcDfnpeNKkRSzL/JkU55nXBB5AdyNATTmy9USHPsXtgVY\nz6b/nbzhkTWiZS75Y2jyO+fOULa7gzJJTi99iJIkSnorSLxpsMbmeXI+SBDS\nKBqH\r\n=sUIP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIB+TlLj+y2n96ikWbTX6TliepxylLDRLLm2L/dj/bBebAiEAgL/+6mq9599QdwtUZl0vILDcsEP7nsL5E1OWThD8gqo="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.0-alpha.3_1620073882428_0.918653715181619"},"_hasShrinkwrap":false},"3.0.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"907fa0fcb7e1456d2c5bca1441f38c4e660f6388","_id":"next-mdx-remote@3.0.0","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-F+XzUXX1SjDR67ZoiqZ9XHi6lApeQAvCu+ZB7XYP95Zkl2fMFLQ5Ul7TM+6SQV27OcBUeopill39OFnV4ash1g==","shasum":"969d553d81af7523f092a1893cf0c59a1e4f4405","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.0.tgz","fileCount":15,"unpackedSize":82752,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgkYQKCRA9TVsSAnZWagAA7dIP/AmTGIRIgYeqDiQ4nMT3\nG7N6AAz9Me22Z8BXPngQOwyJf2XWkCibPqSZBcLOmJRGIsGi2EJau6ona64E\nZEy6+kVS+XoY9RMGwRFCQlfRT6L297fpR5WhlobL7APs/shU+0fDXS9s4YxK\n68ahoHZPPPDO9VOvUeq6YP8C12T5TikLs2ra8K/MYxu0U5eUxmwvxs7koeIT\ngHZaP0NL3QtW4msw4M0N8ZRFL4jD5TsL3tqkY6buc3WjFJNc9FamqA6v16TW\nS67RwAHHKRG441nIUnJfAVVrROCF0SlHNF7Yzy+1bEgcVsEAy8p8B7jvyICH\n9g+29hXWyLAzhanNBQbqiMYQMNktcYjK8Gzi9NP/yUA/R57QBJ/wXyrot1BB\npiIB3mg4yPJ2omFdrdeYNfjF/QWK3SisD6GuCWkX6ytDH158Lsygz8wpm56a\nDioDeKoJwhJ3yOems5heDqeKiBwT65GKxQfFBB7XsH6d7eHhMYWhTZ/v4Vbl\numFH71UGDtest2JNs9Hz8OzYOjexpqAuXABO37Pe3EBzDJYCFIjkgJ5WaUhW\nQzIguCNv3AUYtL8BEyj0w0x3uv+/nHKRR8zLw7D7twfeqzxSD5DoAoQk1ort\nG22b+9PfVGJCv+egRwiyBIVp9rxBX/aWWGTpY0iPfgewoVr/WIT8LiihB3l/\njbkO\r\n=maLl\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICTTzBhoErhJjHARudhPNO0cYPCnUdJZHp8YIFLxhbSaAiB+DUNDf30vjyJnxsVR3eIJfokjEjrGlS2x6xJAGm8z5w=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.0_1620149258388_0.9112084541580823"},"_hasShrinkwrap":false},"3.0.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"3d1c70759e6450b1384567823412199a0119bcbc","_id":"next-mdx-remote@3.0.1","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-sV1sM6CkdYP5aPND1+vrF3wr8TU8NJwVlcFe2rPjVHR5J/9M2bl9zlhF6AF+GOKHA7d5kUdwHoLbApEGofD8hA==","shasum":"2e6901c5d72c62ef3d90c53e7d827cb79b5cd968","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.1.tgz","fileCount":15,"unpackedSize":82786,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgkY70CRA9TVsSAnZWagAAsdQP/04fdilkY6nCDpPy1LFM\n1sIdbfVn/XMSffiEbnKcuod0gVtxNC1Oe7XAOQEo9Op49J6FARnoUrVrcAB1\nPJkcPHtB/x5fSYHS9PIPWDr1ZoXsh12tFKz4saAB5o0/fggi1uHSjhCY5NxJ\nIEJNfZgsj7b9eqzndjibyuUp6IcmaY7fiHOmQ/TXA1s+oCI+3JHQRLMPe3Q1\nKuNh85eUA7o6M+340tGl9V/rOfZQ9+W88nkl7bNPdMY10fA2aJFKJdiqQn1T\nz/jp94DYel2WNjOuo9UYmUXGbdVvG4iTs4FSnd3WHFHUnql+P0a3RFPlZi6W\nWB9TBFi0bTDf1f52CW0YAPoJ2rVu6KDpsoTyScNDSuOY/M9IEGL1jSUZO3f1\n9narjjgKzf5X5nihu0ucjIz8gNz8v/RAjBRkz+fIBF39kQSrqeZi0pUTRmq8\nWO7hO2sIz+rT7ReSf7/wkYTiCTVThWuVZjBGVvtDYZYm6LBYuSuu3bn+MQrA\nJ+On2Vf2DD58EqCfGqhHoDpF9GpuKLmb76q+lkF2GsjGeuDLD/CQG5IQmTgf\nNPM4dgampnE2heS92Sn6Vv5zjgXVx8Ntmt/BiAgpGtcpmFD3KVhbrFDrbQ+h\nxKBJhxQA6uSGfLay0n3I2KsDox7IDBgAFrZ7okjpgIgO+Q5jwdAPto4rEBlp\n3FkR\r\n=EMdi\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAGAN9ap1Fa6XGKihp4jW9ZhTQdGnhJNp4DzhFSftC/BAiAN6s+zNq8pOPwYd8gzC4jNzLkytL7QdgzCk7TRETxAfQ=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.1_1620152051668_0.45402839845560483"},"_hasShrinkwrap":false},"3.0.2-alpha.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.2-alpha.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n- [Background & Theory](#background--theory)\n- [Installation](#installation)\n- [Examples](#examples)\n- [APIs](#apis)\n- [Frontmatter & Custom Processing](#frontmatter--custom-processing)\n- [Caveats](#caveats)\n- [Security](#security)\n- [TypeScript](#typescript)\n- [License](#license)\n\n---\n\n## Background & Theory\n\nIf you are using MDX within a Next.js app, you are probably using the Webpack loader. This means that you have your MDX files locally and are probably using [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow is fine, but introduces a few limitations that we aim to remove with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Early testing has shown build times reduced by 50% or more.\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data (component)</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing custom data (serialize)</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. If you need to pass custom scope that is not just an object, pass `scope` directly to `<MDXRemote />` where it's rendered.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test /> and some data: {product}'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, target?: string | string[] })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Specify the target environment for the generated code. See esbuild docs:\n      // https://esbuild.github.io/api/#target\n      target: ['esnext'],\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n### Caveats\n\n#### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX, is transformed to support: `>= node 12, es2020`.\n\n#### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport serialize from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"22010c6703ae19f51252c221c2edaa5f29421073","_id":"next-mdx-remote@3.0.2-alpha.0","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-idVFDendGVBulcPTeyNdL8Vj/DtJ/51Alorb+bhKpNshg1vpdtYHeNbJyFvRxFvtIAlsul/vOX/Q0SZzE7eQaQ==","shasum":"a9cd233002a70450f41919069162f59ea50212af","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.2-alpha.0.tgz","fileCount":15,"unpackedSize":83341,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgnbV4CRA9TVsSAnZWagAAAbQQAJ9gtIukoy3kZCgPnAtA\nBCeoV07R2UXtRoyVvq0hsiC4ftIdxDu9b1zHjBDjWExSafJ1zkdUPEeq9U5G\nmEB8VM+3M6FtqBDSHZRicwtjZF44y855eFtcEp7FbEHKBKpu2vzoXD+HHXPq\niVY7JWyzMJvSOEF+67r2s1FkdDDVR7/g2j/djTIoACuFUQDcmyDKq0Eo4GkE\ngAenMF4vi0gbJKNBRKF2QoW3axXo/JpKuSKWqg8FEhbl8DmyB2ruzHplD9CO\nWHEim5YCwQECXswwTrNt4eWvMCX6pVYcTuaDp7eQI6zsWLfkfEnP91TH07om\nWvXVwWj1G+U7glNaUs0jqpAiRumE0jEy7iI5ua8Jii+iDtuTPGCjvlAfzDNo\neAMNW1DcCRmM9gFbYTAM/GxGvdvBiYwIXt8wrc1/KVnIh1Z3i1VrxiKWmNKe\nMcWoacrPIM8Uz4Q15MUIVAKylhMT6OCfe7fHTeVo4KaLyjtsVU+X0bXUUt33\nPqagucXyasdlp51hnCO+f/sUmaZ/MbcnP2nNyNf3fMTD03UbP4w65/g3+BeX\nz/qXtKjs7xz8EjOYyd1nJPi0ptJw3YqciX3eTnhCBt0Cv78Zhs+xS6K/T5LN\njq2l6jl3UQWY3HP3PtreYyrMdP7u4WBCO+oj8lOIscTJmogDrVEupB2IRnZt\nCnzU\r\n=upZ2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEs/FZP6YKvr3ye+71qJZ8GBlEkwiBe5NlHQ4nZlg+LVAiEA8N2DJl/3KApL4L+BQTkLTkyYcpChoMKUg6CPhBdBfrY="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.2-alpha.0_1620948344299_0.7729410140592272"},"_hasShrinkwrap":false},"3.0.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.11.12","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"567588ede1e58b9d52c77a0642551e21edf399fb","_id":"next-mdx-remote@3.0.2","_nodeVersion":"14.15.3","_npmVersion":"6.14.13","dist":{"integrity":"sha512-imLrrw6c/Hi1BKRyJE9yLhk45N5zzw+/CxSQRHOAByYUSOhd+DNjUaqm2jtd+/GgxJeYB1d3fJPXmvUZTez1MQ==","shasum":"7e1159b4eb8a6bdd4000c0b6e6631f94d8683f04","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.2.tgz","fileCount":15,"unpackedSize":83351,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgonubCRA9TVsSAnZWagAAq1QP/1cxCieDr5dpwAovtiw7\nJAbrg8vDEA9abZx244cP7+AB8t3whqPXn08z1AXsVb9W8ep+cwYwXNeBfD+o\n9+HlIl5a1tLexiVRc0B7bDSMD39NGuoCV3WWKuxqeev5xfMpI7k40W1ttUHC\nrga9mdlcpxIp+YvVjuy1puB4usqPpk6dMhqWT5RPnsnd9j3SqCYa3VyllWdY\ngeIdvb4VO4qko99fg9X+U00n4a2b/bGCYXRrvVV33c9o51a7Xoy7HzuT+Tp9\nyo+7h8Wh/0URXj/H62ZXxnI86WnF4zayAy/mVRDRknZgG5139pUqUsvh0d+1\n48cjVxxh4/5fGG6Xeo6/LA3fxT2RO38w62jL0eDowwxaixnuQmHltpteDEEZ\njYJ9/uYefE3mfvb/DUiNC5byAPF5hkYtVdahPamiy8dmRAAfDFFGuk6Kp9yy\nkqb2yM2Vl32kN3FISIj+auSiRIqmhbS/qNVyTigkPJ6CRE0kLkpvM/TgSWVT\n67qi9NHhZkM/5FAFePSVhtacsX8dfE52EhC/lmSktz1kl12qPzzzGdVzaInG\n5fv/YiMmoaql9AV7mKtf5qcpR0wt5lDQLm3fZQBJ4pdcVnLocyBSgevBeTN2\nKZWTQLQWkjsO9dwWv+CCbd+jXfERxh7atgy14sQeJfmRRgxHHw5YT32ex44P\nAfOk\r\n=Bojf\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD+RwCLJ6UdZLmQ/Ibtr7VVLNVI7twhWmpv66Kgq4P+rgIhANlIj2FO3hdMRnwK9BgMukAvNlLqX3x6elWmS2hpVbTA"}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.2_1621261211298_0.7501752462881766"},"_hasShrinkwrap":false},"3.0.4":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.4","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"452755393f2bcadf1807f6398bf1429069acba42","_id":"next-mdx-remote@3.0.4","_nodeVersion":"14.15.4","_npmVersion":"6.14.13","dist":{"integrity":"sha512-n/xN6GaeBgJiuTJDrG6iqJ2EY5rEZ99Vf2H1nc75MNn1a6XnZLgT6uQJxqbSN84svc9aU3CSxfRlOqgqVVPHIg==","shasum":"c9b4aff4ec0780b08f34ccd6be966e569d6d4fda","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.4.tgz","fileCount":15,"unpackedSize":84718,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg7f5uCRA9TVsSAnZWagAAn1MP+wZRytDVeV9KErUrVgZ7\nK/+c2OF8YMXJbgopFYCuuX2fatxHRDZ4D2Quq3UDmcFLF6/BG1CY9UwMW9FU\nSWBSpoVOvjeFXmqyEfgHvD2xLSo4HxPvLpuwDGJ7SYodBErdcLcMeoc5jIw4\nnHIhUO1Tj79CDtp1JwYRLWxnDEByJfjrEkYsp7oBGsJGWH8yfrp+RevI23U5\nPn6lpFH+KxTwFx4sZlr0IXv/HNXGPkIiZ7q8C1vAL9lkbKqauyHqRiV6RD3t\nhLBDvhLZNRCODpoizYUs56H95N8AEHhg1H6mbBGB0UyI7Ozd0cH6cek7e8+y\nflYXE8Eh5lFIykrSwJdoY3VdELhCQSAWCkb20i/KcvfXp+GGuYj5dxw7RbOT\nxhFx5KRDgs9P8us4D1vlAVCGt6VMkBkUb393YeoGrkA02ytzVbVnrQCpD2rc\nw8c3ZL4mxz760pKJ2hRi3k3C/e5gP+9x0Uh8Wp9AMo6LeXh5+qW6ygKxcNsj\n/S+3HfQW8CdgYcue2xRGmQrN+U+JqFEzGU2fgt/4eiAgFvjAlu1FGyUPVRer\nNGRv8mgZJ5ach9/9YaVDyHbr4LfNhyYrxfFdrVjHCBh7E+3Z5mSOYfVU6NhA\nhYkSlv5uAxsjFOL+fduUqX/rgtAHc3yZs8ROM2kuHypZe+dxgpZKRpIQveXx\naw19\r\n=zTSS\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCOuETz0WYSs4Vk1jRTj1KgsfwTM1nXLewdNLtJoLFSQgIhAK6qatD+jRBrqCIzlWWg7nw/AHd/0PZKgi/Z/mQ/Khrt"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.4_1626209901750_0.30264923800464594"},"_hasShrinkwrap":false},"3.0.5":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.5","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"1d727508f22ba399f8d4554bdd6ae5137dfd3ed0","_id":"next-mdx-remote@3.0.5","_nodeVersion":"14.17.6","_npmVersion":"7.24.1","dist":{"integrity":"sha512-m9OD2GBuqvz/IeM/h4kufQ7GEdaCaZ4owqkCQ+yoxzCIM7jVQYK9JWXNVcyPP/Y6FBS00fLH03Hn5VFdvkFf0A==","shasum":"57b3ea156d20e622b51becbacedc995233cac236","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.5.tgz","fileCount":15,"unpackedSize":85180,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCv95+XVO2UyKz85SIwsrGxAvYyT74Dlza2inn9h28R5QIhANcRE+pfCjSWFfLEXw8m9gUzZOLIwoI8TOKDt/WK4ygK"}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.5_1633018900954_0.043235670497009604"},"_hasShrinkwrap":false},"3.0.6":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.6","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.13.4","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"8b32e4de0e69b5be93c462ebcd33cd4e8900c479","_id":"next-mdx-remote@3.0.6","_nodeVersion":"14.17.6","_npmVersion":"7.22.0","dist":{"integrity":"sha512-nLyDACEvebCwZonab29/AayXddgActZRcWvtsX8KKzxeRQH4Kjm9/5psD5ARU6ZTa3lALhVss+nCbejll3o5/g==","shasum":"e8ccfc2d2f126a3d269e23c1e1b2a8f623e94520","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.6.tgz","fileCount":15,"unpackedSize":85180,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC8Zh6qKuG/2mR+EW0nRHBwM9DGxBIik6BFSJFTCXxYsQIhAJYNZTfadXepNhRDM0A2QmBFpnWH161WeGFiwAIeYLeA"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.6_1633921366179_0.5666776584221174"},"_hasShrinkwrap":false},"3.0.7":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.7","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"9b1fd0977d437ec0d3147374b8cd21b0a9ea6fc3","_id":"next-mdx-remote@3.0.7","_nodeVersion":"14.17.6","_npmVersion":"7.22.0","dist":{"integrity":"sha512-qLHf9nJHozhnntasYWUD+Y3xGAitMaG4dcS0qy+AxjS4pN241qwH6Rbik53ZqOA6ZCFWBCB/Y1HEQKDFnq1rew==","shasum":"37d93cd1722b2f0ed21cf3e6da09e30907bb21f1","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.7.tgz","fileCount":15,"unpackedSize":85180,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAotOQWKSDRG3t8VkoopzhEOv/c2enFLs6RD0psCoqk3AiEAqt6EiMODD0+2kvmDcmBwlByJJzYXCsPO9tVbmhw6ry8="}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.7_1635345702681_0.9204563950502027"},"_hasShrinkwrap":false},"3.0.8":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.0.8","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^1.6.22","@mdx-js/react":"^1.6.22","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/preset-env":"^7.12.11","@babel/preset-react":"^7.12.10","@babel/preset-typescript":"^7.12.7","@hashicorp/remark-plugins":"^3.0.0","@rollup/plugin-commonjs":"^18.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^11.2.1","@rollup/plugin-typescript":"^8.2.1","@types/babel__preset-env":"^7.9.1","@types/cross-spawn":"^6.0.2","@types/jest":"^26.0.19","@types/mdx-js__react":"^1.5.3","@types/node":"^14.14.16","@types/puppeteer":"^5.4.2","@types/react":"^17.0.4","@types/rmfr":"^2.0.0","@types/serve-handler":"^6.1.0","cross-spawn":"^7.0.3","gray-matter":"^4.0.2","husky":"^4.3.6","jest":"^26.6.3","next":"10.2.0","prettier":"^2.2.1","pretty-quick":"^3.1.0","puppeteer":"^5.5.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.45.2","serve-handler":"^6.1.3","tslib":"^2.2.0","typescript":"^4.2.4","unist-util-remove":"^3.0.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"npm run build && jest"},"sideEffects":false,"types":"index.d.ts","gitHead":"c1f78cdac6fde8444d9069a14b272a8be0288ce2","_id":"next-mdx-remote@3.0.8","_nodeVersion":"14.17.6","_npmVersion":"7.22.0","dist":{"integrity":"sha512-WFSxt0crxG5PN/0WvaunzxzqV3wh3dPBZyhkclxwyQfLSRKzsNSArzot/4gYTOOZ/GtyRfNjbI/HtDsW2S4fqQ==","shasum":"ea2e7f9f3c99a0ce8167976c547e621d5930e1e0","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.0.8.tgz","fileCount":15,"unpackedSize":85371,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDCJio8O8MKuXik64qWMXnPgmOLTCR7I41oB2aSYrIGFAIhAMORmsuo8d1Oioy/lLIVLnLmvJTDTo0q90uI3ifWMrTz"}]},"_npmUser":{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.0.8_1636387924139_0.6727001815271041"},"_hasShrinkwrap":false},"3.1.0-alpha.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.1.0-alpha.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^2.0.0-rc.1","@mdx-js/react":"^2.0.0-rc.1","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/mdx-js__react":"^1.5.3","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","gray-matter":"^4.0.3","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, target?: string | string[] })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Specify the target environment for the generated code. See esbuild docs:\n      // https://esbuild.github.io/api/#target\n      target: ['esnext'],\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX, is transformed to support: `>= node 12, es2020`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"e6c1cc77ea5b4f8ef6f5225d012102ef247af1cc","_id":"next-mdx-remote@3.1.0-alpha.1","_nodeVersion":"14.17.6","_npmVersion":"7.24.1","dist":{"integrity":"sha512-4Gfku0AW8fYDaMzNDtm78+Cp4TkS3QoKlY48ZzJ1fcThQGZ+oSgtzBqXyMzWuqtD3FdZ5DlxzgkSxsngJd5T4A==","shasum":"16305ad9a7ef05c941af471904b5af2b09e3f070","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.1.0-alpha.1.tgz","fileCount":16,"unpackedSize":86189,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDTOjagHjre//U7dl1epsX5m9blYZhWt/NHCagNBQukMAiB5ZcWFEnSR0Jgnwd9XmMBPE1EQu0HQQooYq0lgHvJq0g=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.1.0-alpha.1_1636669867058_0.8381782883459716"},"_hasShrinkwrap":false},"3.1.0-alpha.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"3.1.0-alpha.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^2.0.0-rc.1","@mdx-js/react":"^2.0.0-rc.1","esbuild":"^0.12.9","pkg-dir":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/mdx-js__react":"^1.5.3","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","gray-matter":"^4.0.3","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/advanced/components#mdxprovider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered as long as the top-level namespace is declared in the MDX scope:\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} scope={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, target?: string | string[] })`**\n\n  **`serialize`** consumes a string of MDX. It also can optionally be passed options which are [passed directly to MDX](https://mdxjs.com/advanced/plugins), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Specify the target environment for the generated code. See esbuild docs:\n      // https://esbuild.github.io/api/#target\n      target: ['esnext'],\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n## Frontmatter & Custom Processing\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. Luckily, this can be done entirely independently of `next-mdx-remote`, along with any extra custom processing necessary.\n\nLet's walk through an example of how we could process frontmatter out of our MDX source:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport matter from 'gray-matter'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source, frontMatter }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{frontMatter.title}</h1>\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const { content, data } = matter(source)\n  const mdxSource = await serialize(content, { scope: data })\n  return { props: { source: mdxSource, frontMatter: data } }\n}\n```\n\nNice and easy - since we get the content as a string originally and have full control, we can run any extra custom processing needed before passing it into `serialize`, and easily append extra data to the return value from `getStaticProps` without issue.\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/getting-started#mdxprovider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX, is transformed to support: `>= node 12, es2020`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"62e45711b580f5acb19137a49267eaea0a7b6517","_id":"next-mdx-remote@3.1.0-alpha.2","_nodeVersion":"14.17.6","_npmVersion":"7.24.1","dist":{"integrity":"sha512-DURK7dmrNRmjEE+VPNSxT2osckwz8alR92e3lGERP1ZJHwnkMOmsRVYK83D3PGxWKVL8WtZiRXi2MoQe8lz6Yg==","shasum":"f612dd3b3525cbe1f60160435973b769db89f90a","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-3.1.0-alpha.2.tgz","fileCount":16,"unpackedSize":85975,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHQmY4zJ/xN7oKf99NXjMji/Sk6yUctUBq4MMQhfdQtWAiB+k/qQbZ9QTcfzC7GbInpoAhfJM77EA3jvTej63yQ2jA=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_3.1.0-alpha.2_1636670044964_0.8418831852555175"},"_hasShrinkwrap":false},"4.0.0-alpha.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.0-alpha.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^2.0.0-rc.2","@mdx-js/react":"^2.0.0-rc.2","esbuild":"^0.12.9","pkg-dir":"^5.0.0","vfile":"^5.2.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.4","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=16","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean, minify?: boolean, minifyOptions: { target?: string | string[] } })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Indicate whether or not to minify the mdx output using esbuild\n      minify: false,\n      minifyOptions: {\n        // Specify the target environment for the generated code. See esbuild docs:\n        // https://esbuild.github.io/api/#target\n        target: ['esnext'],\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> =\n  async () => {\n    const mdxSource = await serialize(\n      'some *mdx* content: <ExampleComponent />'\n    )\n    return { props: { mdxSource } }\n  }\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"805366228716cc5478fe60d26f968cdb1f10d226","_id":"next-mdx-remote@4.0.0-alpha.1","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-abw7/dBBc5JHO9/VY6vv8Du8Au18GyWWHeAHyMyUPiTrCltPVcxGRmSSm67a/km6qCsQ8LBX6OJlNgZ/AJOelw==","shasum":"e544eee539e223d2ef81f0671528e5db37225aea","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.0-alpha.1.tgz","fileCount":19,"unpackedSize":155654,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhmAxrCRA9TVsSAnZWagAAkg0P/0byMeZn1LqJ6eUVuVO2\nx4LZgjrlVJ34NKxhPqWwUZ0qb71TSKImr8CJY2xnqDKKri8iFNhcFBVhePHE\nqxqZ0IGea75k5NEqIelAdWqztk0fpSzCh+RhR50Cwq3dkkVfCvpUfPuq0ycL\nD4PsoYuT8nL/SWcP5sbA/72EHJ5VbkVu/JKZg4wV+yKCOJ2wp7ZErl6uo9Co\n0jW0XuD3w8gFUQVS14W6VQyvrpGjOBXyjxUt78cdw3ThKtV5sFYf0DsqqY4O\nhilc3HVBOtHoToC2/y30GS90Vy9lIzb2t5kfBUdRfXWYJn6VZu90qx3H58un\n8BuxENR1NLnL7befzsUdfbDoVkFjrMiLqI/+DGWGSwu1+iggpXIWvkmR765w\nRTo7Mf9fxIVxutJ78HtyGFLDNCAalI1AqA5d37ydSo5wCsCZR+tfx/KHGclN\nWIIYRHOpYALZY37n8N9OiZb3bx9a0BOxu7mm1pMoVbljIAehwSnYulfVBjlG\n3Gvw9WmsTkd36uHAfG/qjsNWIQhIOr3PDsgUeFd+d33ekmyfFyczTmYVQocJ\nJdK9fq7oj3BdSJ9haat4kdphFd/D68RSahrS3ZH0Per+lb3E6+bkUwD4TUeu\nY+KlJXaYrL3bGoNd/yJ8N/SVO0W5s7r59SjWmom/udIZPCSzuSV6Ar5hjy1l\n1EtU\r\n=7gs3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDx5Tb95P+MNDD8heZ20P+kVp+ZCfnyUQB7igDCw7TSbAiBbupOnuUyTlXNIQ8ru62lU4AL4PQGcB7QbJ4I6Sj8bKg=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.0-alpha.1_1637354603121_0.06536408223743595"},"_hasShrinkwrap":false},"4.0.0-alpha.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.0-alpha.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^2.0.0-rc.2","@mdx-js/react":"^2.0.0-rc.2","esbuild":"^0.12.9","pkg-dir":"^5.0.0","vfile":"^5.2.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.4","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean, minify?: boolean, minifyOptions: { target?: string | string[] } })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Indicate whether or not to minify the mdx output using esbuild\n      minify: false,\n      minifyOptions: {\n        // Specify the target environment for the generated code. See esbuild docs:\n        // https://esbuild.github.io/api/#target\n        target: ['esnext'],\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> =\n  async () => {\n    const mdxSource = await serialize(\n      'some *mdx* content: <ExampleComponent />'\n    )\n    return { props: { mdxSource } }\n  }\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"c459f2bc35ee552f1576655bd7b6a0251dc26473","_id":"next-mdx-remote@4.0.0-alpha.2","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-Np9ICaCOHX8vE7ilM6r6IHrm+OKbjQuXvLI0vymDFhN7mDMffhNoAnuAvHJS1jQwsNbKDtruflEE42MoeS/YsQ==","shasum":"aeeba1dfcf6de9a3af305ec850204134ecf1e89f","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.0-alpha.2.tgz","fileCount":19,"unpackedSize":155654,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhnTXGCRA9TVsSAnZWagAAB98P/j1hS8pd84LbW3s3MwnG\nGHriLBK0w+s96TjHsHjiKlVrmSrWkEktshk3IoCGX97rnCFnnsqoTimXK/Q/\n2jMsLiR5bK0DDuq6lKe2aPo2VPO3hzV/W+aL+I715XaJtEvWrxJxLbLDIIBP\n5IYDm4SLKvWZ3Jkw+C0RaAAggUHS2mfdWRzKrYOZ+BLKBHZBKHFwmj/sLXZA\ndMHXrd+6JQF5+mJUDJkegNK68R3Cfvsoxumo6K2Oqfww+xRocurciHPuyQZH\nLUi1ELB6U4thA/Y8BaRuo51Ru6adUc639QUEcHCKfcfHo/WOy6I3vDQm77bP\nBow7uRAkMMj1hxcwwCdYbSQ1lpS+4L97oJOheyV9Vggb0XVRypyu4n3DNO7/\n7P6jW8moT7BQoBMxB//G3/idQhvbFYhsGn/1WGtUOAYfpnKUkjBQE/eePsKj\n5z4d41Y2EidGfmgGKRFsll961UuT4wyOHDUdHcDdZCzm6KhibvdoxATp0ndN\nD9jFsaEBsTuslWpo1X+o+XlS84k8/YZ4sy5vXqxnUyboai5iqwR7cbbTj/Pu\nCx//8AQFIzd2tJcBKli51jMKkX/puI83Ydjwygm7ATmUcDnTVgnpD/EQfXjo\nRJi0M0KFhng32+csv160rC3/AvzUyk8DpMXr5U9ny++TnTZ4WGe3cByUtihM\ndnOu\r\n=AGvv\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHjfNOSRbPZHT+Bg8jRr8SZNKRLnTtbbYjpGEoW2q0sZAiAbUplvSf0sfOe74vt1Yw+vvLU0uRcKB6/vE5BQyURrmQ=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.0-alpha.2_1637692870222_0.9128941551796492"},"_hasShrinkwrap":false},"4.0.0-rc.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.0-rc.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"dependencies":{"@mdx-js/mdx":"^2.0.0-rc.2","@mdx-js/react":"^2.0.0-rc.2","vfile":"^5.2.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.4","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<MDXRemoteSerializeResult> =\n  async () => {\n    const mdxSource = await serialize(\n      'some *mdx* content: <ExampleComponent />'\n    )\n    return { props: { mdxSource } }\n  }\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"c7020ed56c4a021ee697ce74479a08ee89add446","_id":"next-mdx-remote@4.0.0-rc.1","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-BkXRT88BvjAJyS9nhItEHdW799CRFsQ9TK00TBJT1V1MAH44XOW+Kbb6nmoszYoNGPudYZydsfzTSOUOvqraYA==","shasum":"120c0c56694862c0d3f672c69c7b8d31f491a584","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.0-rc.1.tgz","fileCount":19,"unpackedSize":153040,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhs339CRA9TVsSAnZWagAA+NcP/0v6dzai5zbsi8pf+tsx\nF4NQfobAbKZ2yxe/nzK7/WDnRchmOKpytLf03+dSMoI6NabPSsDXqvtPKdr1\nVaOQPDXPwLsTGWFrlJLybce0w3elsXlOu5GZ0D/ewaH+JIsGZYEkn3N61sJu\nAhcOKaLAMUP9WGdY+0PH2RmpG/zn7pJM2uEJI4OIFuwvhRdRv/kyx09FK/3P\n2DcOi5M6N9IGK2bU1XAeWKe2UBXA/8+RCAVrBbLVqONpkC5YyN+JSTHkstMM\n3DU+QhJxjlOl1mN5FnBdGT9PorqtbVi4WfFjcgE4pOJGtPmx/tCcGchKf+lu\nSKHsBULhYDkKEBbquvgNICTOXbo7GphBChS/lNY/Pz3quCAAPNNzzipG0iih\nxhZEi3VMStr/z/rDbdrIvEck/Ba7eh8Ez1wT0DvgIyejk5yxS4rvcbZi5ZaG\noqlPl2elxa5xV9FNzoosC5vcNHBVPB/4gYEEG/9cwLI/vHvDrgqtidIds8uE\nvZ7iY8T4zrEC/vW0AEoxajSKMvcqLySf6uKWt7Zc/yFWhVR6SraSmsd7v1rO\nA6EZ2Z4LVDBzLIDxm2ehjVDr6AaAERYBFMXckwdQNNZYcEzihD4UHZgLrFar\nVo7Lstv0hBSUlXK/cRjD8ccowCgge2RDUjJ61hQ9/S7ws4kCS897s9ijxai8\nhhSq\r\n=s8oJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDTsDejegi7EBLpsNVbnfu1osy42aQRCeZN4EtD1ONGwgIhAMgGIK1AavXRQYdoJ2JQ9KYKzBUfeB1c+2k+lGnQkDAp"}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.0-rc.1_1639153149226_0.0716743931446282"},"_hasShrinkwrap":false},"4.0.0-rc.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.0-rc.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.10","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options at time of writing pulled directly from\n      // https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        hastPlugins: [],\n        compilers: [],\n        filepath: '/some/file/path',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://github.com/mdx-js/mdx/blob/master/packages/mdx/index.js> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{mdxSource: MDXRemoteSerializeResult}> =\n  async () => {\n    const mdxSource = await serialize(\n      'some *mdx* content: <ExampleComponent />'\n    )\n    return { props: { mdxSource } }\n  }\n```\n\n## Migrating from v2 to v3\n\nSee https://github.com/hashicorp/next-mdx-remote/releases/tag/3.0.0\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"4c80b608a1086bedcf0f6fc1194fdcf7ca66fe19","_id":"next-mdx-remote@4.0.0-rc.2","_nodeVersion":"14.17.6","_npmVersion":"8.1.3","dist":{"integrity":"sha512-N2XBxW/PCYKkC/ES/Z7RlGWtDgs7Sskp2mT+H9GUPWhC/hj7/1kVyC8RMYGYy0jLA1ljjbIHM/yUdW4AgzUSrw==","shasum":"dabafa4d9bb9ef89cb637832071296629bd480bc","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.0-rc.2.tgz","fileCount":19,"unpackedSize":153119,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiC9m5CRA9TVsSAnZWagAAwWwP/14YsHray758UudDOiBO\nQ5+cziaGp7kuPmGqqrB1/Yt0nQGqRsf9jjFLMv3arD0GeqkPOrWO2VeihORV\nE5TNPB2a7/5b5BVny2U7mrQPxLj6DUKyw4GgYRMepRgCp01vduCNU6OWdZaT\ng/Km8NG+TRDYUFAdbUUPqNXTuDZO5Ik+O0bTkllsAXXOpMuQwrcZY2QMInHD\nT7n8kyq7tl8Lp3wKIlRRI93xeBhImfp+KQ8q7YCqQ1P+JL1N5Vy0Sk0E0T9q\nO+H5VFHEGd08bT0TRH/bRZBR2QKWXbXaNZ73Q86kkPkhJkP+t/b09nsJz3Wv\nGvcf8Zzu++HkZF7WoNa3Z2iMZ/UZoLd6MzoJXP5t/waxZrtIwwcbLiP7o2Uu\nx22LNxYK22b1Cwl7CFalIpP1j2LS8R0JW8XxZhP1N4iAaldR32vyF6097KWT\nbimib3kC7uuuHvIq100vfU3Hr8hXWsnM7WSHeICBXL5yWnvUxi8AaWW3SY5m\njsKhA91lQiptBh7N8xUwXeEUYFp7ZtO0+14rlBRC4jWdcTqQUe2q+cKjgHrO\nkG96iuZToS1uVNkmYbLmU/miCex15GEcMunUgx7vJ/I/ZLuhVqrbbZzrV2ZM\nY2KHuga0tOUBiemDXZni3dO/FtcU5bTnBXtqgvXmxW9iYnNK9wTdYJ41aYBF\nLIN1\r\n=jtyi\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBEWAmq170nPj/C0obQv22SqQRw+GM/PZSmUpPcMcJ2QAiBSVRVlGi1tck7LWQEWZBtr8DLTpgWWCymJq1LvoayVeA=="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.0-rc.2_1644943800926_0.9199203460214214"},"_hasShrinkwrap":false},"4.0.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.10","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"e1078a8218d27b4c362b893302423449949be1ad","_id":"next-mdx-remote@4.0.0","_nodeVersion":"14.17.6","_npmVersion":"8.1.3","dist":{"integrity":"sha512-WEEBe5OaIiiACvWsYwkf6uFnVcuam33dghDu2WpALE1BcH8Oozwvmjb0KFLURuAQsYL/yOZCTr8urmYtOZifRQ==","shasum":"f76e09344e1b8df9b71782df14dd1a0a442d30a2","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.0.tgz","fileCount":19,"unpackedSize":153114,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiD+EpACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr5qhAAlr956OiOLhMTK+6T3hT8Ml4KsPkKnopMDTML5a930MvfEDsC\r\nO8KTsZoGw2V1BgMwyu+EdazfTKkMaDABUjLBZ9/zpiO8OktWnZ2m1Am5uF8m\r\nwg3Oa3Jr521eabEpk4gE+RvoGoLBcqUYSL3ijZrkdMjTkAmQaRyWg3nQTJ+M\r\no8V0DxIEiW9mxI5YcmD9RjMKo6aVKYyE9BB5F88LLa8J9Pkq+HWnLuMzDckA\r\n/JQLUD8YwFDerqiopkUyBxPscQHGOVYwahHKCRVQid4+X7/Tpb6p3NVJ78bO\r\n1ujoBfi3vmbPOXJarMq0iEMDCuDQKnwBvyk41qjuhGAIGHgkVF4AFwlIW+pp\r\n/LmG0pfNpuE7ydfVcmnQJhViD6CAT+MjbSB30/5NOfjhYHgX7EYzIJimrEmk\r\nSh9SakirDaq0VhjkwWLda5XFvAvYT56CUp9LssL/ftVXCsdssWctrXGFDt7k\r\nSgfN/zUNhmjjYyLiuTEmeWhvqp9gGilGwgLJxh5Pn15ZaSjTcEajKa07Eot3\r\nwbcmmDSNfkdpcqn1MVO2bOqFy4oRyNzooa77gAf0AWjA71lCf45ZMIxHTAxx\r\nsz5MgTi8bmLfHTjUwvAECk7SxbtuTXJXQRV/Kt3ZLsh0ps54+k5l6Ycil92/\r\nu5XLCn/L0H7M2IeEd6LCRyGy7PtnPOIlA68=\r\n=e2ji\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGATMhLM9NWftL4eSaJ35Bxh86Q+Tm75097lAEKiFYOgAiEAqnwPOfOPZCJ/jwzAXqzk6j1j5q0v0eLcl6UBzNaRb9A="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"bel37glbc@relay.firefox.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.0_1645207849247_0.24304585998637984"},"_hasShrinkwrap":false},"4.0.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.10","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"0f111a377b1363135e5a94423db90b1f1b50d88f","_id":"next-mdx-remote@4.0.1","_nodeVersion":"14.17.6","_npmVersion":"8.5.4","dist":{"integrity":"sha512-voQce8q4uFAArDJYNvpgMcJi9KaWuXpaGKQvaBJGVSzmLGMSBZbM+3F7s8Iflg6o9phn+G0hUUpHKagbRa1BQA==","shasum":"9dfdb2198cd139f8691e82912aa8125b5bf74ff1","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.1.tgz","fileCount":19,"unpackedSize":153108,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPfxJACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqNLw/+Nczgu36t4soUgRTHR5qqpLvwsuOlAY8/GNM4jqzcvSHnxywW\r\nnVeNljw7YSOEbscZCaXVqPjwmaVzlIydxDlEeiorOiPRFWKadmHwLMq6exPe\r\n8qR257Sru8YvoZGtRXP8FwpwaXQWswbE/UHKlRTGn+volmF/rMWwMZnjgkI/\r\nxRm/YSnYdVR6H1XbcgnOu6VOSsu1H2kUnJHhWoGaJzZ/ayzP9XaCt09E6O1e\r\ntvU8JLbCSxCUmrjlim7aG6YdotBCdHTNytVoAspHQ6f5szm8kvETZewNjazO\r\n6fJvyPw5UwCVqEwjqqvxdSwHHBKjLi777XCDt7Jy/b08+en2KU1K4gyoIGzH\r\nkPvDRdub0oNxiHLAzkk+05YvGlBQ6wRhORPHm5A1J0lf/sSQmvMxVJcSb69h\r\nl3ij2iKpH2r3Fr+MjqzjNQtyPixMU9WK1AZjP9pxsibx9p43SazYtyGxoN1r\r\nFFvzhVMph2l2wDRqeGYiVmfIbstW8V+OtPJHfhIYGvEgA2cRD6lmtJbIFz5s\r\nXE2JOe7KtiIFU/+MJqlksxWPfY6oL4nYSFTO+YsocAgEy3i1VmH6zrXXqqE3\r\nlawsVSS0gAsNZ+NWE/taZVwtI1YzmS7C3FuwpC++K51Xk0G3yMkgfdQMbKvh\r\n2XpIeeqbm+XXjxOj2VdfVytE7TVhWGKW8pU=\r\n=0LYj\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDTRz7/VHhvDw8sQ2KgNciDQTyNZ8X8S+7mojLHlLWjaAIhAObRW7p8/QI4WmxOFs/X9BtTCXLqKVVK+UECeXYMb+46"}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.1_1648229449312_0.8568033986302643"},"_hasShrinkwrap":false},"4.0.2":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.2","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.0.10","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^17.0.2","react-dom":"^17.0.2","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=17.x","react-dom":">=16.x <=17.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"f072fc6e479a738c1fc6d745c34d1be09521a792","_id":"next-mdx-remote@4.0.2","_nodeVersion":"14.17.6","_npmVersion":"8.5.4","dist":{"integrity":"sha512-1cZM2xm+G1FyYodGt92lCXisP0owPeppVHeH5TIaXUGdt6ENBZYOxLNFaVl9fkS9wP/s2sLcC9m2c1iLH2H4rA==","shasum":"56c315819e6704dfb1fe68ce2f5ed0d315c34528","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.2.tgz","fileCount":19,"unpackedSize":153114,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPj26ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmoo5Q//T4BwFtfmrwgJuWHZRxbGr4kN01hquJNVMUmDBdBJuC3A/Ry2\r\nICVSFlNdi6QQ4wTOx/Yk7WOWDloOcAtyAp1aaY4kltsFMO6LX4WTV/nk3Q/F\r\nIuzClb1dIzvLIXkepwApOkjcwmJcgU+/qm5s3nqzSo3eEnw0xMo9JRL99pKp\r\nW8tz2uLbc6Didry+BaoDL8GmWyogeVKYf1BmMX/p4EiLrTlJS47aN6A9ikcS\r\n6djAkbFU2HbzHhNTGLyTUAb+HyjQoDYJXHajaVl3bQP33JICZ8OYzoqECWly\r\nLglvaIbAGnoO0inuc+ahpij76AAjUXHBUkXzpPRk98q4vPe1W8antSsO1Ghj\r\nStgC6LuWGysO8Lf8qgsxwaMoQzerGsY8WLFSD+LQxTloTLz3YQxuqQFqFCH2\r\nJvMAv6j/W9aFn2lx+saYJdpgcCWKpzuc8vbqSTsp8UNm7eHhXcVRuEfxzhNw\r\nK4QopVZ08dxhrllYNciTnhWJBQLijDfl25Ha3fMdQE7gpl50cdGuYOOgmvuM\r\nLjkbMvFpXE59BC+L7yVccPd1XSDdOY2dmtXIuCwqh06kxos2SYKvQvmGBiEN\r\nJtvxPP3nNrTM0WnWq4sF+uuj4LzVs32HsVFM6vU271wzzoleDtRVZ85e3P/x\r\nmC+6xU7pO9vbhdvGXFAVyTtkI1UJ0uXz1bQ=\r\n=q6uS\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIF4fdBIw9Bvm7uNkRJiuP51UWOEK2/fa1V0I7ztCSEtGAiEAsLQXZ/jWrJnCkhUzFxGAKDytBXDbNyO9MHKHZkFBRXc="}]},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.2_1648246201803_0.04374809204609398"},"_hasShrinkwrap":false},"4.0.3":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.0.3","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.1.5","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.0.0","react-dom":"^18.0.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"23a910dce7ebe2db62d63b06cdb2d1331ada13de","_id":"next-mdx-remote@4.0.3","_nodeVersion":"14.17.6","_npmVersion":"8.6.0","dist":{"integrity":"sha512-jKpZyBN0cOUmfBRId5iGpplWOO79hV2A5qfo17VG4Avn0G5PEs6vR9vf9IngKEw1G4aVqzhCs3j9CEbMFzZoAg==","shasum":"1f614363249f075c81d7b81cd24b924d6f8192e6","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.0.3.tgz","fileCount":20,"unpackedSize":153763,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDuU06nR5neLewrhDRh8g6PQUBjY0fMTwkM5IbFIRByuAIhAJ2oe0fhkY3jG8ZHxCXi45mHwOWiRoFxHcQTJlQG1meC"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiaUgIACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpXRBAAhqIKWf8yHt3M1FtbFJLjnBiBITSs5Y58qkjDGp+8J0FbBRl2\r\noDpgEP/bhe7swIVaaoy5ltFWUbpgCR6rt8efvoUQOBh9L18G6nR+QrQ6SiTe\r\nYa8NTL4VNU8w6DJ6m5GUmP96Tajx63Y22hOsfFzcQdeuth1pLI4ZlVG2VoVP\r\nLpm7+lPWFFawZtqu8CcMpo5RZlu9hz2qOp8lGh2Ag6ySC2A2QIDHdFetDJ8n\r\nr6+tULV9fYo2gA5FJcF0F3odB2eaNrEPKBrWJJ2sWZ5tSW74R2Hict+BtoVa\r\nNLDimIZEiptqXhkm+cWnRREh7//Nz7K/1bR9OaiTW8id0my+uZkYeYYblJk4\r\nxqW8QKHAPlRKp8qE9pnJaB6KV9IQoDSlKsiHK+qIAiMNf6qlWd62kffKnX6R\r\nAV6Mp7fwZG1Xs23dLjHntV2hbafS1enBpztpoI8P2A5zKKxWsIj9dghNV4NU\r\nZLiZutV/DHhvbU8Ay/eh+1EZ+IJxsPNSYQFfwsseJje4zidYJK7mIofORA5y\r\n9hTtqAUDeeHDo8rx9ueUCf9jaYube8GIFzG7pb/4SvwfBSx1rMOpvQcBQSV6\r\nSTmxaxXcZzxIMPdkFP3eeDfWKiAWWNgYzRRW5JPQ8+5CZfLOjyjyO5ECve+V\r\nsbEbi5kFP2SSB437RUNX92Jzuq9LVrerapA=\r\n=XJkA\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.0.3_1651066888582_0.21359005301647582"},"_hasShrinkwrap":false},"4.1.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.1.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.1.5","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.0.0","react-dom":"^18.0.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"b3809656ea35fb18eb2fbcf7af2e3aaeaf0e09cf","_id":"next-mdx-remote@4.1.0","_nodeVersion":"14.17.6","_npmVersion":"8.6.0","dist":{"integrity":"sha512-ZdL5AFJcEqvInGkYYRKda930D6AJt1GOLX/OXFE/vTwaqV/Mw+l3/njZ4kWqvYSAkl89Z6W7WZrTtN0fd0XwPg==","shasum":"5e063542437a8cfa3faa9623870b076c01429c2a","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.1.0.tgz","fileCount":20,"unpackedSize":153476,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDstb4MkRpCg/QxiPl0VMtt39veQOXkKcofKXQSAVFCIgIhAJDBcGH1t10CwVGhwjiWt9/wXLQ0P/q4VvuO3GYttsQj"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi2ISDACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq9lw//dQTila+GtOH31w2ft+BcQN2EKdC01GCq+hLkN+wFo4uE7Tpy\r\nwAY+y1FgnFuF4z8eVMqdiDcz+E8zbQGuo6kxWm+dsn5B+8eMeaCwJwJX4IEb\r\nCa6XuvGQmN6DALnoOr/zebCsKfsnwcWtWpZ8mC6CjuZKevhc0FK6mtgL+xgo\r\n7w0SroZSMItBKfDIXZHyFYgE5rPlbRDMHTaCEl5vLQFOQJmRYV+Pzbp4iQ/I\r\nmumMfs5ZqnW8wYKN2vsECDa/1iOJvxu917ZoorYW2XqolTLgyP2ppncCur9h\r\nX2HSsgSpenn7LK5QYokWnw83hAK1Ne6bp+lp8/vjM2Fq+bszpBn+nrYQ/j8n\r\nzWxSb5gaoj7SrdgwjZs9GYaRyzpX13LylKMqFEWby/ghrYnSdOyEPFK2wKYl\r\nPjv8AXUN6x0SwtoHA7FCLR+vqbAn9uk4fgOVi+0UASI0hqt2DUaZJQmFUxqE\r\n8d5KEZ3o7pCvQux8NWB2j30kzIepNO1h4Stc+XyDXnkXUNSS57hUGooc+hSF\r\nw4H8G8nxrPoniEJFHteVaYIt6gHb8Ho9rLCPcxbNtG9yOnTERQN3bpU4atoR\r\nFlo6j99JUUC4hhvrLwZMiLzdiWmhxoCRHMBq3WsUiu/qdfGOiCCkIPnAuzx/\r\ns25qEtvBqeet38AswNjL7NeDp0pVS/umwpQ=\r\n=fUUF\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.1.0_1658356867226_0.037325082142971366"},"_hasShrinkwrap":false},"4.2.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.2.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.0.0","@mdx-js/react":"^2.0.0","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.1.5","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.0.0","react-dom":"^18.0.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"e9e132422876e20c1dff025232063fc2ca5b53be","_id":"next-mdx-remote@4.2.0","_nodeVersion":"16.13.0","_npmVersion":"8.16.0","dist":{"integrity":"sha512-X5RhD7f7b78pH2abbuusObSGgII5l54OdusS/2iXljN7WN1cel6ToLlZeCZcyxx9cR4wmBGQYGongIttDYNmAA==","shasum":"322aaa601d00e34bd27302443c793d432ae16db8","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.2.0.tgz","fileCount":20,"unpackedSize":153524,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFVOEWs1x3H34snwFopj5cgQ7KWFdMssxkTbfKCcdb3OAiEAzURYGV/5jCdwQiDgr/lm+VRkjy1OSCQlV2lbSUJih8k="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjaJV8ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrCkA/+JTgGBKNpa+hnTXxa7kLYKxSETCxWQ+x7YiCtbDNKWJtGn1D/\r\nWZ/4sNjUMdmkr9Xr43MSKApVnv529OFyUKpxKOxYkJp6Z6TEc0xAZ72B/EWQ\r\ngcVt4+QltgxHWDY3CUyx+X7DLR/nw5E5FA5kA8oWsZc/fGgfl3fYA1SmyM7j\r\npnatQhyAUols9f07dYEXsqhmVaaAN58M/8moTqleCEUHe4BbqULQ/FijylCn\r\nNur6aHXRXg0od3E691v+zxVawiN8XoQpfTB/BTK3mwqlt2u49isx68V59tVL\r\nqjTeSHCz7552/Bc08dYemO2UT999IgFLFRuhJ2Zpk2bCgi6FIRmypr48zZtm\r\ni/2Ew+e31K+md+VMABczVNm9qtCGiEIjiOpyk4O8VvZwLsznTAt7scYg6q48\r\n685h/L09ISfWsiH0xqJrB2n+H3W5LVWVO/LFpQ21N66dAeuZyMtObfkf6j92\r\nqsA00RhvIqEw1OzfcSkALriz1kdnfA4JYmupeg2hXrSjNESPKKx2Z6qcf7lR\r\nlwztUb4i5AqKwvuGPsJb6MIQeocR6JAJMr79F5Pt6+MrEAyIdYoRqF5n0eWg\r\nF6gQYA/oqZLz500mfWh8F9u1CrxeS+XkskYx6Zk+W9RinYwOGl8qChf0T0Tc\r\nWWaUCmsfNXGtLD3ynyln8tvUwEEx51veLWM=\r\n=WvsL\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.2.0_1667798396634_0.986587060987292"},"_hasShrinkwrap":false},"4.2.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.2.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js"},"dependencies":{"@mdx-js/mdx":"^2.2.1","@mdx-js/react":"^2.2.1","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^12.1.5","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.0.0","react-dom":"^18.0.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"jest":{"testPathIgnorePatterns":["fixtures"],"transformIgnorePatterns":["/node_modules/(?!(@mdx-js|unist-|unified|bail|is-plain-obj|trough|vfile|remark-|micromark-|micromark|estree-util-|parse-entities|character-entities|mdast-util-|character-reference-invalid|is-|stringify-entities|periscopic|hast-util-|comma-separated-tokens|property-information|space-separated-tokens|zwitch|ccount|decode-named-character-reference))"],"transform":{"\\.m?[jt]sx?$":["esbuild-jest",{"sourcemap":true,"loaders":{".mjs":"jsx"}}]},"moduleFileExtensions":["ts","tsx","js","jsx","mjs"],"verbose":true},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","test":"jest"},"sideEffects":false,"types":"index.d.ts","type":"module","gitHead":"e912ff5461ed28d1d43baadc8a359eaf3ed39707","_id":"next-mdx-remote@4.2.1","_nodeVersion":"16.13.0","_npmVersion":"8.16.0","dist":{"integrity":"sha512-PcVF1r5XTBjiNVXw0GyaIcOwQsklHo36+7ycfmtJb52TIkT0nM4Hzv4wgJwNg7+jvTbap99qWsMwdKUYR9WxAA==","shasum":"1aee0207b029487100ef49740be210595fe04e50","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.2.1.tgz","fileCount":20,"unpackedSize":153615,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC9Ws+1h0ORvWgi1tNUzFx7qkQmm+HjwbhTVjqTn7sy2gIhAI187Xaw4imLNU5rhLOmR+D1f+Qa074MdH2zcG3UlBQ1"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjtv2FACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmog6A/9E5lGTkcDPF9FSqsaegT1FBu8+sJAqGTyRQ9YjVx/KqzI+Mkd\r\n+fNXVRigkAThtXEI/xGG2yQH+kvYRHPsRiwDhKNboP114mBV444Q8Xep6yke\r\nXlg/4dIrZyU8gkg+mOL13s78UYHcV+ZnbNnouJl5HrRkmCpMFWmsyNZe8smV\r\nwP5i9uI0KB5dhltZkDnDdtqcN+gPSbAMVwrVfzjrBHWMPPEzRbPX5ObeLepZ\r\nXadkeDGalX/GCH5z4rIv9hKNWBc0YjV1IEaSSe9SynRTQTmlHswyHMCHxn7D\r\nCX7wFX63jT7ezmV20pKsm15Wyh3ukG3Ur2T1UfrUckwg7V3rmaIuSLPs0Aqs\r\naqJDHoYqmdLvGtk7N3+6axi8NGu1HcUDr0hFYz+Dnt28XwpvwiTpkyEMBd94\r\nNDAxwJfGi1no0gKbDZYEMGD2FYfztzFp/TvXVQUDv5fAMeYs6T2J4gNmqrg0\r\n56bbAERUIJP4bJ5Mmd48sxvAEukPTVFkpiIToq3Bw0K84XNBuLRMB9wSuI4E\r\n9jalWd9Zk5DxmyjyJpJedIBZhNcRvO5uUfWALAQq2pIG4Ci+5iZ5Zy6IoSXj\r\nkdJ+MCXAfvt7/1o8yAk8VEHjwRDfPA/JYFAhob1TAuCrk8qVKFMPSN2Z+jDU\r\nB9Pl6j2pq3mC2xI3sGKuG9rKZD+0XnMP8Xw=\r\n=lSlE\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.2.1_1672936837088_0.27570462033542253"},"_hasShrinkwrap":false},"4.3.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.3.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^2.2.1","@mdx-js/react":"^2.2.1","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react-dom":"^18.2.0","react":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"jest"},"types":"index.d.ts","type":"module","gitHead":"82cfaad6f38d30a6d00eff1117dc7fd529d6628a","_id":"next-mdx-remote@4.3.0","_nodeVersion":"16.13.0","_npmVersion":"8.16.0","dist":{"integrity":"sha512-fbxkY03pM2Wx5bDNTVKpYD5Hx3QVZGH+6xDtVIxlxXz4HTifP1yI2DrkDvxXbTz0SYGIbluRMIW81IOOa8pigA==","shasum":"34c5223c8a6465ab4484e8b22efff840c510316a","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.3.0.tgz","fileCount":24,"unpackedSize":239985,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCJLp6A1+O35cyo6Ns2jafr0nFOQgMMOMM6lEHQTwfhVwIgKF4HFJO6nbqWks5v3j4eaUJZknWBxZhwyehmEJ5EEEU="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjytYPACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpoGw//fr/5e9rjB5MrCITsAIfqugW02r3WrZY3Y32t4dOZ2h6PIrg/\r\nQDTbLw7fVKkQI9vjZIkx3p5UdtddrU1o/6eg62Igmf3oOzyfPu73KvixBWim\r\nYz+251+59HAfzjqWsO3e9AK4kFMCjNtZXykTl0DuDNPQU29ObcYBrHXGoMDp\r\n5FhG6EFsRebU4MPBy43FvsBb/nks2AEVaya+iBFAuzgqJNOgT+r1rFWWl8rM\r\nqO52UVWG/BimbOp/iAuXMms8gtB7TuY1lqUlWBeN9hPyMAF8G1MvGb6yHwpB\r\nk0lpJg9c2PNWjKlUh23jdQhzdsFNn2igGeYDJPHKDk1J9AIQ5c7eOSnYQ6GU\r\nhcZG8L0Bf5khpCo0yhL6i4lq5VKKa5AocHsBeyPsyvM6yK5mIzlMcNZ3MTuq\r\n9GeX/lXgfnZ8ic5oqWppNEYBPYl/MpQMTnN0UzESTXqtKumyi7H8LDPuFMGt\r\n4J9FUR89owyfvGAw2RhKMjLPAuhlAKKSqrgPDOcU3oA7ZhyFFqgGlhbSuAow\r\nQ4/DYQM0Za3Weq97TmXaZPqVoIv6t88y8V7SgSvRRjbb6C9L+otenSy1ztBj\r\nTx9h8L8KHLsC7IpNFFR0BaiYN63QlIbT5O0nuPAkfhV9DQyEc98cds78NyOa\r\nM150qhm7f3fCQfnt31ycYJqZeGFKvcSajFw=\r\n=fgZS\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.3.0_1674237455718_0.5094739011735967"},"_hasShrinkwrap":false},"4.4.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.4.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^2.2.1","@mdx-js/react":"^2.2.1","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react-dom":"^18.2.0","react":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"jest"},"types":"index.d.ts","type":"module","gitHead":"ce066d791df7b30fd79b9dcce2d52d15582d9edc","_id":"next-mdx-remote@4.4.0","_nodeVersion":"18.14.0","_npmVersion":"9.3.1","dist":{"integrity":"sha512-ejIZvhsrphvw47sw7zrJmJzq/faDFPODaLxAQIarXiBc7PtxToYSHm0QKZZbaxNPiIQZCl/1KVNJm6WDfIYX6g==","shasum":"ead1f4682b6e7a380ce4a7f95931e7cea9dfc632","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.4.0.tgz","fileCount":24,"unpackedSize":242254,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIELYJgUmuYJvt2Hryj7Aw9ERG8hVYXJaeymp5UGxTFGyAiEA8uqoKYIxS27idHIc0/Al+Ky/vu7JITKM40h7lcwv7zY="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj/h/dACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrNYA//UvLjFu+UCSdS6ZqlxkmCTzWY1s3s8HVM8CE114JcJMaKktj2\r\nP+jDzQXHb7iUq6lub7cMgF5XCMYl+eehnYZUy7Xv9vkasIB3wCUH21wW07/f\r\nRjNePSCa304u4UXa95via4Z+jIGybDrRxmBcvAyRqMNV+X2Z4zDnHQAu9aSQ\r\nWLBnMJfpMe89MzEGeW/pYJSV93cv+IbTHNOePlv/A1G8a3ZsGfQWQWIfcPIa\r\neTlM+DNEwqpDA00RfQYQ3TzWF+1fbDXK0H1D2XQb3MtldQbrgxSYR+5BiB48\r\nG0jQt3igy8ebG2ROq2nLwELnMbLJ5cH1mAYOf3RVEXsl9JHq1E5uJDfZV41L\r\nqViiyUnT5xEmukYUIKUtllm/VBD6GAv8ItHNEMUYKLvEdQcqH7dEFEvOx4Fs\r\nAG7K9aIpjVcBsxwwfVesOrQtpZyPQF22bpQQ2JvnI1bfhIe8D7dUncudNMSA\r\ngUylogZeiVZbmBd5V5mcPMgjVvNvxsytj4JFcP0ncglHoZLKt6vDBuulCq0Q\r\nexlcnrSVy28WhF89LoWRFPKLKmniQoe6VQZe4xtAM/e2FHyjWtDrFL+ydqBv\r\nq6x0Vdee/oXJycQ2gDLiwOHAjPfEKt8ys4IFLZlDWuP/FuH6e09V0sRDOV+Z\r\n598mkbWDZGOMt0Lpraa7Ggk9r9zzPfE1Ypc=\r\n=5jfV\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.4.0_1677598685092_0.13657921105894633"},"_hasShrinkwrap":false},"4.4.1":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"4.4.1","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^2.2.1","@mdx-js/react":"^2.2.1","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/react-dom":"^18.0.11","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"jest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","gitHead":"1c8acee5d1aa9e22814165e15c344b62f8aa284e","_id":"next-mdx-remote@4.4.1","_nodeVersion":"18.14.0","_npmVersion":"9.3.1","dist":{"integrity":"sha512-1BvyXaIou6xy3XoNF4yaMZUCb6vD2GTAa5ciOa6WoO+gAUTYsb1K4rI/HSC2ogAWLrb/7VSV52skz07vOzmqIQ==","shasum":"96b16e2adc54dbcd0a7f204a9a3c3fd269d41abf","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-4.4.1.tgz","fileCount":24,"unpackedSize":242689,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC/gyq8cMasur17N1tnKD7ALQN0qOLvlt9eZn+i2+HhqwIhAI3ZqNtefF1kEx7WRdVp03/yeERsR29OM4zNAPLtpJEB"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj/6KlACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoNDBAAiFY34wnXyHP/4UqQ2URaQl8wiyWdOx4Uq6S1kXvR/ToRsFH4\r\nbs/CM8Cx8y9ubj2TmpBXQJbqfzCXYlLr0wnu85WtEJGSGB5I7G2wvLJtiWRR\r\n+QBZh4t8Kg9QpJhiXQnD7Pbf6dL0CpmZFFsrNxO+bU4vpO4EtA7Ayukyv3+E\r\nLNfLpO1UzyrfsufdeZ7/xmUOq+Erk9x4P2yQGmUvS70gnr3AvgEWcvwVGEc6\r\nqb/JOHwlR8n32iFoPwCY87lPhspSK3iRSTgaOiU3vo1QkjEVJfWQw4+FsEJP\r\nC5DsycL3nACQmYV0iyTbZoJP0HM3KSk3SDj3/nKyoidQNQ0MCsAO+pK7QHDh\r\nWBnWRt/Cif1oF1PM9mNe+Omb05wKYRzz6KTAv/TCUqE/v/r0EC8HptBdoXxJ\r\nVSWU1FuiZVLQi22Cih/Bezn/tcU6KfPgLykvjllE1SUi5UeeOcJdQjKrREmV\r\nu+UM2P5ZxGNjN0TPUy8AzTihDmiCWgXWew+yxaPSVfBvGo0ouFutCRAbFYHU\r\nCMwqcXTzSlhj+8gQm26ueJ6HvMXY4woc7zFEj+oqWXG1/caigMVJbKgSWCCd\r\nx7Zhhs7NE+HwyeadRWNQgXf2ixwRIT31T73WnuVjTqVeu/MJiOMJlXO6f/Wc\r\n2xo+7APhkz/kTK8Xic1/sjoGLbyVek6U4os=\r\n=barf\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"bkalow","email":"bkalow@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"bkalow","email":"bkalow@hashicorp.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_4.4.1_1677697701532_0.8279412968616826"},"_hasShrinkwrap":false},"0.0.0-canary-20240313180836":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240313180836","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^2.2.1","@mdx-js/react":"^2.2.1","vfile":"^5.3.0","vfile-matter":"^3.0.1"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^27.0.2","@types/node":"^16.11.6","@types/puppeteer":"^5.4.4","@types/react":"^17.0.33","@types/react-dom":"^18.0.11","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^27.3.1","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^4.4.4","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"jest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240313180836","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"9a91743aba4042faea5e9e3999a18bda82f4d9ff","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-xH35A6QJJBZomcSjSHokLNV7KfTAUtbRp03iscPXel7vXFEviaWfLNS5NmTlmE40b07efmHV3yv0+ZfKaOsZug==","shasum":"546e1af27eedc10cba89214a7f88675d7d8990e5","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240313180836.tgz","fileCount":27,"unpackedSize":246305,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICmdGpeSM4CZbGGj5XIHSsi9qnAU+Xb03UG3CevIuD3xAiEAsYO0Y9k4WUzUrEyEaUaRmVhliYqGPu5K2f48QFpoYxc="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240313180836_1710353333207_0.7697054954111977"},"_hasShrinkwrap":false},"0.0.0-canary-20240313201809":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240313201809","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^29.5.12","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^29.7.0","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^5.4.2","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"node --experimental-vm-modules node_modules/.bin/jest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240313201809","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"56f2d24091e3ebfc5a9ee662d8cfc3edcea2f0c5","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-6EidCJAR7KGUW59nBfith62axj7PHmld7pU1y7VrRz/gTPfx0NM93fmd4TOYVJBxOjpmbyitr+G+oCW/DuU9Og==","shasum":"3ffc95b6fb8fb7b6ce58841acfcd15697f21a253","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240313201809.tgz","fileCount":28,"unpackedSize":250978,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDIDLidtXIa9T9wNHSI6oMlnio0X1jp0ZIbmWDIuw1l3AIhAL1nO8KljAXVfTEwhSu1v7hP++X5cMRX6kc5xZDbTn55"}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240313201809_1710361106707_0.32191798168727903"},"_hasShrinkwrap":false},"0.0.0-canary-20240313201811":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240313201811","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/jest":"^29.5.12","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","esbuild-jest":"^0.5.0","husky":"^4.3.6","jest":"^29.7.0","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^5.4.2","unist-util-remove":"^3.1.0"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"node --experimental-vm-modules node_modules/.bin/jest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240313201811","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"56f2d24091e3ebfc5a9ee662d8cfc3edcea2f0c5","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-H6RsY8AculVviAMBGZCiUQ/b5S6+ISwynlFYdS/JATaKEMnMY2Y2LdPZaRU/yO0m85YamD66MipO+a3ho+WXUg==","shasum":"171b02de2eabe72c4d681e77217976688a419241","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240313201811.tgz","fileCount":28,"unpackedSize":250978,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCPAKu8o59zLMS1gzYXnYJIWV6YQRte2qDvbm1yslXQCgIhAKf8TQdM15NhQGEvUrxc9jnk5FZr1O2T/J0Pm4rV+1SZ"}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240313201811_1710361109140_0.3101212388903041"},"_hasShrinkwrap":false},"0.0.0-canary-20240313235304":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240313235304","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240313235304","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"08b17d767e024ca521ba2acf6af4349e4f38e853","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-dSzZMCQ4M6IDpGlZ3yPWKO8QgknSbagGG2nD26WY7WsEyZH2JemX7T/0rtYluM4fNrvIGaQa5AhWoq3VPQCsiA==","shasum":"e3465244414c71d4a3b94b3173b4d8f709ee4599","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240313235304.tgz","fileCount":25,"unpackedSize":245062,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIC2FZHkP8yPJuvlsqXbx0CSHykvLRSqWi/gawlH2u42vAiEAs8XUJ2Xb05qaUw8QjtJ9D+LlbHBRQDatNfbw9QVLPHI="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240313235304_1710374000818_0.1374170217621824"},"_hasShrinkwrap":false},"0.0.0-canary-20240314000534":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314000534","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314000534","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"cef9d408ec66eedeb4357f08f1df33c4b86ec422","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-WxUZ9TYXuT/Z9f0IJtae11GPJLWRxL79wgAWLbieByID7gEo/085x8XNPPWRSLd2creekc3+ldxnC5iJ2khAVA==","shasum":"93592e2983e88d4c08df950556d6448055e9c451","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314000534.tgz","fileCount":30,"unpackedSize":90882,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH2Qy0+rf6bTbuG/8EJcOKSsWGE3uvX98AVVki3S4VgjAiEAuTvFzQxHeG9zR239/3rmMFjCqbD3aqDBnVHR4JQlO/Q="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314000534_1710374741631_0.927758712859476"},"_hasShrinkwrap":false},"0.0.0-canary-20240314000547":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314000547","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314000547","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"cef9d408ec66eedeb4357f08f1df33c4b86ec422","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-YPl7chRk4x9hP30r+1pbwsh2nrn9J8q1sTMqFBpaxamRG40dwl3bKT3krb8s5tzZ1AeGNuLjk6erxttVIGRP1A==","shasum":"942ba7a8e46cf7860117ca2c123140e14384db77","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314000547.tgz","fileCount":30,"unpackedSize":90882,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCAY6AXiLZWwsUNqFlF85Xt4ZwUm9Xvll4ZytOZq1kTewIgfIrzeo6xGIb4zC2R/cfM0bhWs3dUBiwc3+SdqjhawcM="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314000547_1710374755219_0.534077968148343"},"_hasShrinkwrap":false},"0.0.0-canary-20240314005824":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314005824","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314005824","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"ef4fe605f497636764d361e5e0ccb7c75353797a","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-STLEZmIwLe8UAegLuQDbRySUuBgf0wvsGl1WPADNtHD6ygSfhauwa2BImu4QZ8JPeO0ZWuOC94mS8abTtD1maA==","shasum":"9f3142d9192c4d1b4846c303f5d9efaee748910a","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314005824.tgz","fileCount":25,"unpackedSize":245071,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEN1bQ0AwP0kZxuKRxWFo6EI8foG32SlgdbwVoB6STmGAiEA+sXtiZhMyYcQED/53/5Zj6ujlaXCc7sQDLzSd/VXKzY="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314005824_1710377921012_0.9047430885206189"},"_hasShrinkwrap":false},"0.0.0-canary-20240314005835":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314005835","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"devDependencies":{"@babel/code-frame":"^7.16.0","@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.6","@rollup/plugin-typescript":"^8.3.0","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","rollup":"^2.59.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","tslib":"^2.3.1","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && rollup -c rollup.config.js","postbuild":"cp ./src/jsx-runtime.cjs dist","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314005835","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"ef4fe605f497636764d361e5e0ccb7c75353797a","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-L4a8oufHdTq+2U25nU24pvKUEKLVYx/UNeEWzFHi8Ke/KHD5Phb0fb2F1pRj8+QU+qjUNCf31a8gW+dt5RKArQ==","shasum":"928489a464bd350501a684696588476bd61d7bd8","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314005835.tgz","fileCount":25,"unpackedSize":245071,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDkUFBSa1mgbQqMFmMfX1hatGaxCkHa50m5S1zyYrRAYgIgFKP9sQUcjvdApNXlpNsnL+TXUawYYQpvDYGlepA3e/g="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314005835_1710377931937_0.8915053684328915"},"_hasShrinkwrap":false},"0.0.0-canary-20240314010824":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314010824","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314010824","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"e2743c603149ff0cfa68bb8f819203c25ca3463c","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-ttzxZD/7shvD+SNZ6DsmWTPVG30DfHuRAa070pcEYQx7NADYiQrtxYyWGzOYSSrewPiEt4WjyOKzzC+t0V7K3g==","shasum":"77c643ba7c8a1b96af09af880678cb7d80ca3459","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314010824.tgz","fileCount":30,"unpackedSize":90891,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDllWWink+/6xvYm1hrLLEhBQKLHQ/jjC5+ezzoflulYAIhALzYq9vU0HAcKSjz7zv6M3573T25puPazW/4eUStkln9"}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314010824_1710378510768_0.9912588921961023"},"_hasShrinkwrap":false},"0.0.0-canary-20240314011020":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314011020","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314011020","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"ea208f912ce485aa7b369ae4ca089502e350009e","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-2KkjOButwTBjFOTiFQNF3gKXV16eeRFCHnmMrLwrw5rzeGEi+gy5daeTa8Aj88EksW0ubWKeqVgJ8zdCjrKiog==","shasum":"dbb9efcfbf7c71b13b797a1f6f095efee1b152aa","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314011020.tgz","fileCount":30,"unpackedSize":90891,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFrEpbuc0foG+YooZbGbvs8xAoX5mnuTC9DEkIKP1wYKAiEA0I9w4kpzQ7Ym20WKMtKJbfikJJ6kAN/3619Iq4pVU5I="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314011020_1710378627270_0.5640716340844567"},"_hasShrinkwrap":false},"0.0.0-canary-20240314172753":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240314172753","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240314172753","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"fa8e945b469edfc8abc6cba3470b1db9b07c2d02","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-jZyxOJrOLDP83YzqymN94DHdX29i7rao0TJyee8Sq2/+z3xuH1QuW1tY+Aoa6yHehdUnsE5/pr7Mts4aVlk1Lw==","shasum":"3f11960b338e31750f348b95874ddf4f5228d345","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240314172753.tgz","fileCount":32,"unpackedSize":92920,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH7PYV1I1Iih90Yd/4KBhTw6o/KHJPEZEmz5bXws7LtwAiEA+HILDmVN2T1mzFyVLymYrlpERmtgoGXXPDmbgPX8U/4="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240314172753_1710437280025_0.9757402161027096"},"_hasShrinkwrap":false},"0.0.0-canary-20240321205249":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240321205249","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240321205249","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"ba4abbe0e0bde29244881c1ad45b9092d81d0b47","_nodeVersion":"18.19.1","_npmVersion":"10.2.4","dist":{"integrity":"sha512-vqerW3tdmFCLtmENseqAF2GPRV6ka/b39//Rhl7zkAMalJ/OpQ6MYqrnLYFlyOc1aVyV/D5IpxjK4Uw071jq2A==","shasum":"cdcf5ccf7928c159bdb184c940c77bf91324c8ab","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240321205249.tgz","fileCount":32,"unpackedSize":93202,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDxnroQkXj1hYNCn8hBp+vacYXFyfeVPFCr3m/L3j4eoAIgbGn+SYwGGIxmsj7KP+kyEELbs1fsxFqvXgTytOOw2TQ="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240321205249_1711054376323_0.8038412457604913"},"_hasShrinkwrap":false},"0.0.0-canary-20240521184130":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240521184130","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240521184130","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing mdx to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\n# using npm\nnpm i next-mdx-remote\n\n# using yarn\nyarn add next-mdx-remote\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with nextjs' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the mdx scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom mdx component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the mdx source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load mdx files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from mdx-enhanced was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a mdx file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal html and css. You definitely do not need to be using a heavy full-stack javascript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official nextjs example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\n> **Warning**\n> We consider the `next-mdx-remote/rsc` API to be unstable. Use at your own discretion, and be aware that the API and behavior might change between minor and/or patch releases.\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"614a16ffd9e1abf11428a77178b3fbecf9cc0612","_nodeVersion":"18.20.2","_npmVersion":"10.5.0","dist":{"integrity":"sha512-y6RLnRYg2rlHQHd39ky874pGpM9+1wN/sL9xYWivgL7N07cJKlX3hprTrmBHdv7LaPYjPeueW4ScvrTNTiF2ZQ==","shasum":"42fcb1f0bc5dcafb3ed2ce7215e3d5ed944a915d","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240521184130.tgz","fileCount":33,"unpackedSize":93494,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDhxRp2aAt8K/w5IZrMCjBspZ+K48IE9jn37dz62fPwqAIgEP+cJhCP1sdV2XYnIJnDzvgOI4Wo3HsB3a1GBcd5Qf8="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240521184130_1716316898320_0.3480916764660622"},"_hasShrinkwrap":false},"0.0.0-canary-20240522050412":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240522050412","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16.x <=18.x","react-dom":">=16.x <=18.x"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:major":"release major && npm publish","release:minor":"release minor && npm publish","release:patch":"release patch && npm publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240522050412","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing MDX to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\nnpm install next-mdx-remote\n```\n\nIf using with Turbopack, you'll need to add the following to your `next.config.js` until [this issue](https://github.com/vercel/next.js/issues/64525) is resolved:\n\n```diff\nconst nextConfig = {\n+  transpilePackages: ['next-mdx-remote'],\n}\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `next-mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with Next.js' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `next-mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the MDX scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom MDX component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the MDX source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load MDX files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from `next-mdx-enhanced` was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C. Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a MDX file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal HTML and CSS. You definitely do not need to be using a heavy full-stack JavaScript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official Next.js example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## Alternatives\n\n`next-mdx-remote` is opinionated in what features it supports. If you need additional features not provided by `next-mdx-remote`, here are a few alternatives to consider:\n\n- [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler)\n- [`next-mdx-remote-client`](https://github.com/ipikuka/next-mdx-remote-client)\n- [`remote-mdx`](https://github.com/devjiwonchoi/remote-mdx)\n\n### You Might Not Need `next-mdx-remote`\n\nIf you're using React Server Components and just trying to use basic MDX with custom components, you don't need anything other than the core MDX library.\n\n```js\nimport { compile, run } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `# Hello, world!\n<ClientComponent />\n`\n\nexport default async function Page() {\n  // Compile the MDX source code to a function body\n  const code = String(\n    await compile(mdxSource, { outputFormat: 'function-body' })\n  )\n  // You can then either run the code on the server, generating a server\n  // component, or you can pass the string to a client component for\n  // final rendering.\n\n  // Run the compiled code with the runtime and get the default export\n  const { default: MDXContent } = await run(code, {\n    ...runtime,\n    baseUrl: import.meta.url,\n  })\n\n  // Render the MDX content, supplying the ClientComponent as a component\n  return <MDXContent components={{ ClientComponent }} />\n}\n```\n\nYou can also simplify this approach with `evaluate`, which compiles and runs code in a single call if you don't plan on passing the compiled string to a database or client component.\n\n```js\nimport { evaluate } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `\nexport const title = \"MDX Export Demo\";\n\n# Hello, world!\n<ClientComponent />\n\nexport function MDXDefinedComponent() {\n  return <p>MDX-defined component</p>;\n}\n`\n\nexport default async function Page() {\n  // Run the compiled code\n  const {\n    default: MDXContent,\n    MDXDefinedComponent,\n    ...rest\n  } = await evaluate(mdxSource, runtime)\n\n  console.log(rest) // logs { title: 'MDX Export Demo' }\n\n  // Render the MDX content, supplying the ClientComponent as a component, and\n  // the exported MDXDefinedComponent.\n  return (\n    <>\n      <MDXContent components={{ ClientComponent }} />\n      <MDXDefinedComponent />\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"914c1ab28e65a110f34705110b5ab70b82371af9","_nodeVersion":"18.20.2","_npmVersion":"10.5.0","dist":{"integrity":"sha512-S6YURR4EPVo/o0VY0TAKBKGji6/UYHAn5SLDe24majNqC8udB+r7iImNafzbBS39+dM9sYaVkzENpx+IiCzJeA==","shasum":"0aca5d9079feb9b572874651aaf695bc9ac5499e","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240522050412.tgz","fileCount":33,"unpackedSize":96104,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA32R/IXQ2UWJkOe2LAmw4Td9NazhvazjDaYvywNoFAYAiBSXNX8Bq+cMzPvB/gN1rb7D4g798bfSuCQG9v+tihQbQ=="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240522050412_1716354260196_0.7510169318015762"},"_hasShrinkwrap":false},"0.0.0-canary-20240522052002":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240522052002","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js","./package.json":"./package.json"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240522052002","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing MDX to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\nnpm install next-mdx-remote\n```\n\nIf using with Turbopack, you'll need to add the following to your `next.config.js` until [this issue](https://github.com/vercel/next.js/issues/64525) is resolved:\n\n```diff\nconst nextConfig = {\n+  transpilePackages: ['next-mdx-remote'],\n}\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `next-mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with Next.js' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `next-mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the MDX scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom MDX component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the MDX source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load MDX files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from `next-mdx-enhanced` was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C. Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a MDX file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal HTML and CSS. You definitely do not need to be using a heavy full-stack JavaScript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official Next.js example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## Alternatives\n\n`next-mdx-remote` is opinionated in what features it supports. If you need additional features not provided by `next-mdx-remote`, here are a few alternatives to consider:\n\n- [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler)\n- [`next-mdx-remote-client`](https://github.com/ipikuka/next-mdx-remote-client)\n- [`remote-mdx`](https://github.com/devjiwonchoi/remote-mdx)\n\n### You Might Not Need `next-mdx-remote`\n\nIf you're using React Server Components and just trying to use basic MDX with custom components, you don't need anything other than the core MDX library.\n\n```js\nimport { compile, run } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `# Hello, world!\n<ClientComponent />\n`\n\nexport default async function Page() {\n  // Compile the MDX source code to a function body\n  const code = String(\n    await compile(mdxSource, { outputFormat: 'function-body' })\n  )\n  // You can then either run the code on the server, generating a server\n  // component, or you can pass the string to a client component for\n  // final rendering.\n\n  // Run the compiled code with the runtime and get the default export\n  const { default: MDXContent } = await run(code, {\n    ...runtime,\n    baseUrl: import.meta.url,\n  })\n\n  // Render the MDX content, supplying the ClientComponent as a component\n  return <MDXContent components={{ ClientComponent }} />\n}\n```\n\nYou can also simplify this approach with `evaluate`, which compiles and runs code in a single call if you don't plan on passing the compiled string to a database or client component.\n\n```js\nimport { evaluate } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `\nexport const title = \"MDX Export Demo\";\n\n# Hello, world!\n<ClientComponent />\n\nexport function MDXDefinedComponent() {\n  return <p>MDX-defined component</p>;\n}\n`\n\nexport default async function Page() {\n  // Run the compiled code\n  const {\n    default: MDXContent,\n    MDXDefinedComponent,\n    ...rest\n  } = await evaluate(mdxSource, runtime)\n\n  console.log(rest) // logs { title: 'MDX Export Demo' }\n\n  // Render the MDX content, supplying the ClientComponent as a component, and\n  // the exported MDXDefinedComponent.\n  return (\n    <>\n      <MDXContent components={{ ClientComponent }} />\n      <MDXDefinedComponent />\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"bbe129f0e66ccf952dcf43388b89f22765f56971","_nodeVersion":"18.20.2","_npmVersion":"10.5.0","dist":{"integrity":"sha512-yt4nQ8DpAyISVWR+uUbBhwBumjty7+jdLHUaic6yLxGa0rqPBnU2NDlmBXpm2AdBnbUxx3/UL7uCH2b94+9OZQ==","shasum":"c34a8d598b0c4ae0e617978211a93bc912789fea","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240522052002.tgz","fileCount":33,"unpackedSize":95942,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIG4baMHe5LeXIbWDq/PZV0MSCdaoy3kThlhO9LwxcizkAiA461UtwQJqWd980kfT8eVhzVPP2ibH31255Dgb5Lxszw=="}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240522052002_1716355210084_0.16816625489948267"},"_hasShrinkwrap":false},"0.0.0-canary-20240522052620":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"0.0.0-canary-20240522052620","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js","./package.json":"./package.json"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@0.0.0-canary-20240522052620","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing MDX to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\nnpm install next-mdx-remote\n```\n\nIf using with Turbopack, you'll need to add the following to your `next.config.js` until [this issue](https://github.com/vercel/next.js/issues/64525) is resolved:\n\n```diff\nconst nextConfig = {\n+  transpilePackages: ['next-mdx-remote'],\n}\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `next-mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with Next.js' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `next-mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the MDX scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom MDX component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the MDX source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load MDX files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from `next-mdx-enhanced` was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C. Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a MDX file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal HTML and CSS. You definitely do not need to be using a heavy full-stack JavaScript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official Next.js example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## Alternatives\n\n`next-mdx-remote` is opinionated in what features it supports. If you need additional features not provided by `next-mdx-remote`, here are a few alternatives to consider:\n\n- [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler)\n- [`next-mdx-remote-client`](https://github.com/ipikuka/next-mdx-remote-client)\n- [`remote-mdx`](https://github.com/devjiwonchoi/remote-mdx)\n\n### You Might Not Need `next-mdx-remote`\n\nIf you're using React Server Components and just trying to use basic MDX with custom components, you don't need anything other than the core MDX library.\n\n```js\nimport { compile, run } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `# Hello, world!\n<ClientComponent />\n`\n\nexport default async function Page() {\n  // Compile the MDX source code to a function body\n  const code = String(\n    await compile(mdxSource, { outputFormat: 'function-body' })\n  )\n  // You can then either run the code on the server, generating a server\n  // component, or you can pass the string to a client component for\n  // final rendering.\n\n  // Run the compiled code with the runtime and get the default export\n  const { default: MDXContent } = await run(code, {\n    ...runtime,\n    baseUrl: import.meta.url,\n  })\n\n  // Render the MDX content, supplying the ClientComponent as a component\n  return <MDXContent components={{ ClientComponent }} />\n}\n```\n\nYou can also simplify this approach with `evaluate`, which compiles and runs code in a single call if you don't plan on passing the compiled string to a database or client component.\n\n```js\nimport { evaluate } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `\nexport const title = \"MDX Export Demo\";\n\n# Hello, world!\n<ClientComponent />\n\nexport function MDXDefinedComponent() {\n  return <p>MDX-defined component</p>;\n}\n`\n\nexport default async function Page() {\n  // Run the compiled code\n  const {\n    default: MDXContent,\n    MDXDefinedComponent,\n    ...rest\n  } = await evaluate(mdxSource, runtime)\n\n  console.log(rest) // logs { title: 'MDX Export Demo' }\n\n  // Render the MDX content, supplying the ClientComponent as a component, and\n  // the exported MDXDefinedComponent.\n  return (\n    <>\n      <MDXContent components={{ ClientComponent }} />\n      <MDXDefinedComponent />\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","gitHead":"82b8b236408a6ac1afefee33108bd305c7802019","_nodeVersion":"18.20.2","_npmVersion":"10.5.0","dist":{"integrity":"sha512-oTJqY/Lb36NUnMReD5r7Rb1h0XEslSqgr+Jwd2rrvDMhklz3GPYj4sAS8JEvxgGnRU+AbVWNIp79m6sXYZEgGA==","shasum":"5350648896a3c816dddb871d8dbd612674239cbf","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-0.0.0-canary-20240522052620.tgz","fileCount":33,"unpackedSize":96027,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDDdoruB4PzMpB36jBvD49QBhw58bgaUl+Nxv8ePRLaLQIhAMn8oIWSz1xtjlB2wiujZTjbcoaZNFwy+mML9txx+9MV"}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_0.0.0-canary-20240522052620_1716355587903_0.7292292394843591"},"_hasShrinkwrap":false},"5.0.0":{"name":"next-mdx-remote","description":"utilities for loading mdx from any remote source as data, rather than as a local import","version":"5.0.0","author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"exports":{".":"./index.js","./serialize":"./serialize.js","./rsc":"./rsc.js","./package.json":"./package.json"},"dependencies":{"@babel/code-frame":"^7.23.5","@mdx-js/mdx":"^3.0.1","@mdx-js/react":"^3.0.1","unist-util-remove":"^3.1.0","vfile":"^6.0.1","vfile-matter":"^5.0.0"},"peerDependencies":{"react":">=16"},"devDependencies":{"@changesets/changelog-github":"^0.5.0","@changesets/cli":"^2.27.1","@hashicorp/remark-plugins":"^3.2.1","@types/babel__code-frame":"^7.0.3","@types/cross-spawn":"^6.0.2","@types/node":"^18.11.9","@types/puppeteer":"^5.4.4","@types/react":"^18.2.65","@types/react-dom":"^18.2.22","@types/rmfr":"^2.0.1","@types/serve-handler":"^6.1.1","cheerio":"^1.0.0-rc.10","cross-spawn":"^7.0.3","husky":"^4.3.6","next":"^13.1.2","prettier":"^2.4.1","pretty-quick":"^3.1.1","puppeteer":"^10.4.0","react":"^18.2.0","react-dom":"^18.2.0","release":"^6.3.0","rmfr":"^2.0.0","serve-handler":"^6.1.3","tree-kill":"^1.2.2","typescript":"^5.4.2","vitest":"^1.3.1"},"homepage":"https://github.com/hashicorp/next-mdx-remote#readme","husky":{"hooks":{"pre-commit":"pretty-quick --staged"}},"keywords":["markdown","mdx","next","next.js"],"license":"MPL-2.0","engines":{"node":">=14","npm":">=7"},"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"scripts":{"build":"rm -rf ./dist && tsc -p .","lint":"prettier --write \"./**/*.{js,jsx,json}\"","release":"changeset publish","release:canary":"npm run build && changeset publish --tag canary","prepublishOnly":"npm run build","pretest":"mkdir -p ./dist && npm run build && npm pack --pack-destination ./dist","test":"npm run test:types && npm run test:js","test:js":"vitest","test:types":"tsc -p . --noEmit"},"types":"index.d.ts","type":"module","_id":"next-mdx-remote@5.0.0","gitHead":"0d8438f27890fbd4e4aa3a3bc3b2fd8ea5bef1db","_nodeVersion":"20.13.1","_npmVersion":"10.5.2","dist":{"integrity":"sha512-RNNbqRpK9/dcIFZs/esQhuLA8jANqlH694yqoDBK8hkVdJUndzzGmnPHa2nyi90N4Z9VmzuSWNRpr5ItT3M7xQ==","shasum":"028a2cf5cf7f814d988d7ab11a401bed0f31b4ee","tarball":"https://registry.npmjs.org/next-mdx-remote/-/next-mdx-remote-5.0.0.tgz","fileCount":33,"unpackedSize":96019,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDE/XZXWSDnWMvYsOg4/vZFGQw2a98hZ9hx5s9GKznOzwIhAN8VVE+MR2oY/zdn9z6R1eSnPsy/KGJ2gPx1xXYOlnv+"}]},"_npmUser":{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},"directories":{},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/next-mdx-remote_5.0.0_1716403014862_0.5194014356370702"},"_hasShrinkwrap":false}},"time":{"created":"2020-04-27T16:54:41.509Z","0.0.1":"2020-04-27T16:54:41.636Z","modified":"2024-05-22T18:36:55.194Z","0.0.2":"2020-04-27T18:41:28.483Z","0.0.3":"2020-04-27T18:49:47.344Z","0.1.0":"2020-04-30T01:28:35.084Z","0.1.1":"2020-05-01T19:19:23.475Z","0.3.0":"2020-05-01T21:33:20.639Z","0.4.0":"2020-05-21T20:37:45.273Z","0.5.0":"2020-07-09T22:27:58.569Z","0.5.1":"2020-07-16T21:43:58.180Z","0.6.0":"2020-07-17T17:19:41.326Z","1.0.0":"2020-08-18T22:39:06.070Z","1.0.1":"2020-12-08T21:09:27.932Z","1.0.1-canary.0":"2020-12-23T03:10:47.139Z","2.0.0":"2020-12-23T22:32:07.917Z","2.0.1":"2020-12-27T19:24:58.023Z","2.1.0":"2021-01-06T19:51:09.733Z","2.1.1":"2021-01-07T21:26:34.638Z","2.1.2":"2021-01-21T17:53:48.174Z","2.1.3":"2021-01-22T22:30:40.041Z","2.1.4-xdm.0":"2021-02-17T20:15:23.197Z","2.1.4":"2021-04-12T20:55:38.171Z","3.0.0-alpha.0":"2021-04-23T20:36:38.801Z","3.0.0-alpha.1":"2021-04-28T15:50:09.680Z","3.0.0-alpha.2":"2021-05-03T15:29:17.253Z","3.0.0-alpha.3":"2021-05-03T20:31:22.667Z","3.0.0":"2021-05-04T17:27:38.574Z","3.0.1":"2021-05-04T18:14:11.784Z","3.0.2-alpha.0":"2021-05-13T23:25:44.505Z","3.0.2":"2021-05-17T14:20:11.446Z","3.0.4":"2021-07-13T20:58:21.928Z","3.0.5":"2021-09-30T16:21:41.143Z","3.0.6":"2021-10-11T03:02:46.348Z","3.0.7":"2021-10-27T14:41:42.887Z","3.0.8":"2021-11-08T16:12:04.305Z","3.1.0-alpha.1":"2021-11-11T22:31:07.215Z","3.1.0-alpha.2":"2021-11-11T22:34:05.143Z","4.0.0-alpha.1":"2021-11-19T20:43:23.357Z","4.0.0-alpha.2":"2021-11-23T18:41:10.434Z","4.0.0-rc.1":"2021-12-10T16:19:09.421Z","4.0.0-rc.2":"2022-02-15T16:50:01.074Z","4.0.0":"2022-02-18T18:10:49.439Z","4.0.1":"2022-03-25T17:30:49.483Z","4.0.2":"2022-03-25T22:10:02.012Z","4.0.3":"2022-04-27T13:41:28.815Z","4.1.0":"2022-07-20T22:41:07.442Z","4.2.0":"2022-11-07T05:19:56.841Z","4.2.1":"2023-01-05T16:40:37.298Z","4.3.0":"2023-01-20T17:57:35.901Z","4.4.0":"2023-02-28T15:38:05.247Z","4.4.1":"2023-03-01T19:08:21.707Z","0.0.0-canary-20240313180836":"2024-03-13T18:08:53.414Z","0.0.0-canary-20240313201809":"2024-03-13T20:18:26.874Z","0.0.0-canary-20240313201811":"2024-03-13T20:18:29.339Z","0.0.0-canary-20240313235304":"2024-03-13T23:53:21.001Z","0.0.0-canary-20240314000534":"2024-03-14T00:05:41.917Z","0.0.0-canary-20240314000547":"2024-03-14T00:05:55.379Z","0.0.0-canary-20240314005824":"2024-03-14T00:58:41.188Z","0.0.0-canary-20240314005835":"2024-03-14T00:58:52.112Z","0.0.0-canary-20240314010824":"2024-03-14T01:08:30.930Z","0.0.0-canary-20240314011020":"2024-03-14T01:10:27.466Z","0.0.0-canary-20240314172753":"2024-03-14T17:28:00.243Z","0.0.0-canary-20240321205249":"2024-03-21T20:52:56.549Z","0.0.0-canary-20240521184130":"2024-05-21T18:41:38.521Z","0.0.0-canary-20240522050412":"2024-05-22T05:04:20.349Z","0.0.0-canary-20240522052002":"2024-05-22T05:20:10.405Z","0.0.0-canary-20240522052620":"2024-05-22T05:26:28.056Z","5.0.0":"2024-05-22T18:36:55.021Z"},"maintainers":[{"name":"jescalan","email":"soft.joy1514@fastmail.com"},{"name":"dstaley","email":"staley.dylan@gmail.com"},{"name":"hashibot-web","email":"mktg-dev-github-bot@hashicorp.com"},{"name":"bkalow","email":"hello@brycekalow.name"}],"description":"utilities for loading mdx from any remote source as data, rather than as a local import","homepage":"https://github.com/hashicorp/next-mdx-remote#readme","keywords":["markdown","mdx","next","next.js"],"repository":{"type":"git","url":"git+https://github.com/hashicorp/next-mdx-remote.git"},"author":{"name":"Jeff Escalante"},"bugs":{"url":"https://github.com/hashicorp/next-mdx-remote/issues"},"license":"MPL-2.0","readme":"<!-- markdownlint-disable-file MD033 MD041 -->\n\n<!--\n\n# next-mdx-remote\n\nA set of light utilities allowing MDX to be loaded within `getStaticProps` or `getServerSideProps` and hydrated correctly on the client.\n\n-->\n\n[![next-mdx-remote](./header.png)](.)\n\n---\n\n## Installation\n\n```sh\nnpm install next-mdx-remote\n```\n\nIf using with Turbopack, you'll need to add the following to your `next.config.js` until [this issue](https://github.com/vercel/next.js/issues/64525) is resolved:\n\n```diff\nconst nextConfig = {\n+  transpilePackages: ['next-mdx-remote'],\n}\n```\n\n## Examples\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\nWhile it may seem strange to see these two in the same file, this is one of the cool things about Next.js -- `getStaticProps` and `TestPage`, while appearing in the same file, run in two different places. Ultimately your browser bundle will not include `getStaticProps` at all, or any of the functions it uses only on the server, so `serialize` will be removed from the browser bundle entirely.\n\n> **IMPORTANT**: Be very careful about putting any `next-mdx-remote` code into a separate \"utilities\" file. Doing so will likely cause issues with Next.js' code splitting abilities - it must be able to cleanly determine what is used only on the server side and what should be left in the client bundle. If you put `next-mdx-remote` code into an external utilities file and something is broken, remove it and start from the simple example above before filing an issue.\n\n### Additional Examples\n\n<details>\n  <summary>Parsing Frontmatter</summary>\n\nMarkdown in general is often paired with frontmatter, and normally this means adding some extra custom processing to the way markdown is handled. To address this, `next-mdx-remote` comes with optional parsing of frontmatter, which can be enabled by passing `parseFrontmatter: true` to `serialize`.\n\nHere's what that looks like:\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ mdxSource }) {\n  return (\n    <div className=\"wrapper\">\n      <h1>{mdxSource.frontmatter.title}</h1>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `---\ntitle: Test\n---\n\nSome **mdx** text, with a component <Test name={frontmatter.title}/>\n  `\n\n  const mdxSource = await serialize(source, { parseFrontmatter: true })\n  return { props: { mdxSource } }\n}\n```\n\n_[`vfile-matter`](https://github.com/vfile/vfile-matter) is used to parse the frontmatter._\n\n</details>\n\n<details>\n  <summary>Passing custom data to a component with `scope`</summary>\n\n`<MDXRemote />` accepts a `scope` prop, which makes all of the values available for use in your MDX.\n\nEach key/value pair in the `scope` argument will be exposed as a javascript variable. So, for example, you could imagine if you had a scope like `{ foo: 'bar' }`, it would be interpreted as `const foo = 'bar'`.\n\nThis specifically means that you need to make sure that key names in your `scope` argument are valid javascript variable names. For example, passing in `{ 'my-variable-name': 'bar' }` would generate an _error_, because the key name is not a valid javascript variable name.\n\nIt's also important to note that `scope` variables must be consumed as _arguments to a component_, they cannot be rendered in the middle of text. This is shown in the example below.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} scope={data} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component using a scope variable <Test product={product} />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Passing `scope` into the `serialize` function instead</summary>\n\nYou can also pass custom data into `serialize`, which will then pass the value through and make it available from its result. By spreading the result from `source` into `<MDXRemote />`, the data will be made available.\n\nNote that any scope values passed into `serialize` need to be serializable, meaning passing functions or components is not possible. Additionally, any key named in the `scope` argument must be valid javascript variable names. If you need to pass custom scope that is not serializable, you can pass `scope` directly to `<MDXRemote />` where it's rendered. There is an example of how to do this above this section.\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\nconst data = { product: 'next' }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source =\n    'Some **mdx** text, with a component <Test product={product} />'\n  const mdxSource = await serialize(source, { scope: data })\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Custom components from <code>MDXProvider</code><a id=\"mdx-provider\"></a>\n  </summary>\n\nIf you want to make components available to any `<MDXRemote />` being rendered in your application, you can use [`<MDXProvider />`](https://mdxjs.com/docs/using-mdx/#mdx-provider) from `@mdx-js/react`.\n\n```jsx\n// pages/_app.jsx\nimport { MDXProvider } from '@mdx-js/react'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <MDXProvider components={components}>\n      <Component {...pageProps} />\n    </MDXProvider>\n  )\n}\n```\n\n```jsx\n// pages/test.jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>\n    Component names with dot (e.g. <code>motion.div</code>)\n  </summary>\n\nComponent names that contain a dot (`.`), such as those from `framer-motion`, can be rendered the same way as other custom components, just pass `motion` in your components object.\n\n```js\nimport { motion } from 'framer-motion'\n\nimport { MDXProvider } from '@mdx-js/react'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={{ motion }} />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = `Some **mdx** text, with a component:\n\n<motion.div animate={{ x: 100 }} />`\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n<details>\n  <summary>Lazy hydration</summary>\n\nLazy hydration defers hydration of the components on the client. This is an optimization technique to improve the initial load of your application, but may introduce unexpected delays in interactivity for any dynamic content within your MDX content.\n\n_Note: this will add an additional wrapping `div` around your rendered MDX, which is necessary to avoid [hydration mismatches during render](https://reactjs.org/docs/react-dom.html#hydrate)._\n\n```jsx\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote } from 'next-mdx-remote'\n\nimport Test from '../components/test'\n\nconst components = { Test }\n\nexport default function TestPage({ source }) {\n  return (\n    <div className=\"wrapper\">\n      <MDXRemote {...source} components={components} lazy />\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  // MDX text - can be from a local file, database, anywhere\n  const source = 'Some **mdx** text, with a component <Test />'\n  const mdxSource = await serialize(source)\n  return { props: { source: mdxSource } }\n}\n```\n\n</details>\n\n## APIs\n\nThis library exposes a function and a component, `serialize` and `<MDXRemote />`. These two are purposefully isolated into their own files -- `serialize` is intended to be run **server-side**, so within `getStaticProps`, which runs on the server/at build time. `<MDXRemote />` on the other hand is intended to be run on the client side, in the browser.\n\n- **`serialize(source: string, { mdxOptions?: object, scope?: object, parseFrontmatter?: boolean })`**\n\n  **`serialize`** consumes a string of MDX. It can also optionally be passed options which are [passed directly to MDX](https://mdxjs.com/docs/extending-mdx/), and a scope object that can be included in the MDX scope. The function returns an object that is intended to be passed into `<MDXRemote />` directly.\n\n  ```ts\n  serialize(\n    // Raw MDX contents as a string\n    '# hello, world',\n    // Optional parameters\n    {\n      // made available to the arguments of any custom MDX component\n      scope: {},\n      // MDX's available options, see the MDX docs for more info.\n      // https://mdxjs.com/packages/mdx/#compilefile-options\n      mdxOptions: {\n        remarkPlugins: [],\n        rehypePlugins: [],\n        format: 'mdx',\n      },\n      // Indicates whether or not to parse the frontmatter from the MDX source\n      parseFrontmatter: false,\n    }\n  )\n  ```\n\n  Visit <https://mdxjs.com/packages/mdx/#compilefile-options> for available `mdxOptions`.\n\n- **`<MDXRemote compiledSource={string} components?={object} scope?={object} lazy?={boolean} />`**\n\n  **`<MDXRemote />`** consumes the output of `serialize` as well as an optional components argument. Its result can be rendered directly into your component. To defer hydration of the content and immediately serve the static markup, pass the `lazy` prop.\n\n  ```ts\n  <MDXRemote {...source} components={components} />\n  ```\n\n### Replacing default components\n\nRendering will use [`MDXProvider`](https://mdxjs.com/docs/using-mdx/#mdx-provider) under the hood. This means you can replace HTML tags by custom components. Those components are listed in MDXJS [Table of components](https://mdxjs.com/table-of-components/).\n\nAn example use case is rendering the content with your preferred styling library.\n\n```jsx\nimport { Typography } from \"@material-ui/core\";\n\nconst components = { Test, h2: (props) => <Typography variant=\"h2\" {...props} /> }\n...\n```\n\nIf you prefer, you can also wrap your entire application in an `<MDXProvider />` instead of passing your components directly to `<MDXRemote />`. See the [example](#mdx-provider) above.\n\nNote: `th/td` won't work because of the \"/\" in the component name.\n\n## Background & Theory\n\nThere isn't really a good default way to load MDX files in a Next.js app. Previously, we wrote [`next-mdx-enhanced`](https://github.com/hashicorp/next-mdx-enhanced) in order to be able to render your MDX files into layouts and import their front matter to create index pages.\n\nThis workflow from `next-mdx-enhanced` was fine, but introduced a few limitations that we have removed with `next-mdx-remote`:\n\n- **The file content must be local.** You cannot store MDX files in another repo, a database, etc. For a large enough operation, there will end up being a split between those authoring content and those working on presentation of the content. Overlapping these two concerns in the same repo makes a more difficult workflow for everyone.\n- **You are bound to filesystem-based routing.** Your pages are generated with urls according to their locations. Or maybe you remap them using `exportPathMap`, which creates confusion for authors. Regardless, moving pages around in any way breaks things -- either the page's url or your `exportPathMap` configuration.\n- **You will end up running into performance issues.** Webpack is a JavaScript bundler, forcing it to load hundreds/thousands of pages of text content will blow out your memory requirements. Webpack stores each page as a distinct object with a large amount of metadata. One of our implementations with a couple hundred pages hit more than 8GB of memory required to compile the site. Builds took more than 25 minutes.\n- **You will be limited in the ways you are able to structure relational data.** Organizing content into dynamic, related categories is difficult when your entire data structure is front matter parsed into javascript objects and held in memory.\n\nSo, `next-mdx-remote` changes the entire pattern so that you load your MDX content not through an import, but rather through `getStaticProps` or `getServerProps` -- you know, the same way you would load any other data. The library provides the tools to serialize and hydrate the MDX content in a manner that is performant. This removes all of the limitations listed above, and does so at a significantly lower cost -- `next-mdx-enhanced` is a very heavy library with a lot of custom logic and [some annoying limitations](https://github.com/hashicorp/next-mdx-enhanced/issues/17). Our informal testing has shown build times reduced by 50% or more.\n\nSince this project was initially created, Kent C. Dodds has made a similar project, [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler). This library supports imports and exports within a MDX file (as long as you manually read each imported file and pass its contents) and automatically processes frontmatter. If you have a lot of files that all import and use different components, you may benefit from using `mdx-bundler`, as `next-mdx-remote` currently only allows components to be imported and made available across all pages. It's important to note that this functionality comes with a cost though - `mdx-bundler`'s output is at least 400% larger than the output from `next-mdx-remote` for basic markdown content.\n\n### How Can I Build A Blog With This?\n\nData has shown that 99% of use cases for all developer tooling are building unnecessarily complex personal blogs. Just kidding. But seriously, if you are trying to build a blog for personal or small business use, consider just using normal HTML and CSS. You definitely do not need to be using a heavy full-stack JavaScript framework to make a simple blog. You'll thank yourself later when you return to make an update in a couple years and there haven't been 10 breaking releases to all of your dependencies.\n\nIf you really insist though, check out [our official Next.js example implementation](https://github.com/vercel/next.js/tree/canary/examples/with-mdx-remote). ðŸ’–\n\n## Caveats\n\n### Environment Targets\n\nThe code generated by `next-mdx-remote`, which is used to actually render the MDX targets browsers with module support. If you need to support older browsers, consider transpiling the `compiledSource` output from `serialize`.\n\n### `import` / `export`\n\n`import` and `export` statements cannot be used **inside** an MDX file. If you need to use components in your MDX files, they should be provided as a prop to `<MDXRemote />`.\n\nHopefully this makes sense, since in order to work, imports must be relative to a file path, and this library allows content to be loaded from anywhere, rather than only loading local content from a set file path. As for exports, the MDX content is treated as data, not a **module**, so there is no way for us to access any value which may be exported from the MDX passed to `next-mdx-remote`.\n\n## Security\n\nThis library evaluates a string of JavaScript on the client side, which is how it MDXRemotes the MDX content. Evaluating a string into javascript can be a dangerous practice if not done carefully, as it can enable XSS attacks. It's important to make sure that you are only passing the `mdxSource` input generated by the `serialize` function to `<MDXRemote />`, as instructed in the documentation. **Do not pass user input into `<MDXRemote />`.**\n\nIf you have a CSP on your website that disallows code evaluation via `eval` or `new Function()`, you will need to loosen that restriction in order to utilize `next-mdx-remote`, which can be done using [`unsafe-eval`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#common_sources).\n\n## TypeScript\n\nThis project does include native types for TypeScript use. Both `serialize` and `<MDXRemote />` have types normally as you'd expect, and the library also exports a type which you can use to type the result of `getStaticProps`.\n\n- `MDXRemoteSerializeResult<TScope = Record<string, unknown>>`: Represents the return value of `serialize`. The `TScope` generic type can be passed to represent the type of the scoped data you pass in.\n\nBelow is an example of a simple implementation in TypeScript. You may not need to implement the types exactly in this way for every configuration of TypeScript - this example is just a demonstration of where the types could be applied if needed.\n\n```tsx\nimport type { GetStaticProps } from 'next'\nimport { serialize } from 'next-mdx-remote/serialize'\nimport { MDXRemote, type MDXRemoteSerializeResult } from 'next-mdx-remote'\nimport ExampleComponent from './example'\n\nconst components = { ExampleComponent }\n\ninterface Props {\n  mdxSource: MDXRemoteSerializeResult\n}\n\nexport default function ExamplePage({ mdxSource }: Props) {\n  return (\n    <div>\n      <MDXRemote {...mdxSource} components={components} />\n    </div>\n  )\n}\n\nexport const getStaticProps: GetStaticProps<{\n  mdxSource: MDXRemoteSerializeResult\n}> = async () => {\n  const mdxSource = await serialize('some *mdx* content: <ExampleComponent />')\n  return { props: { mdxSource } }\n}\n```\n\n## React Server Components (RSC) & Next.js `app` Directory Support\n\nUsage of `next-mdx-remote` within server components, and specifically within Next.js's `app` directory, is supported by importing from `next-mdx-remote/rsc`. Previously, the serialization and render steps were separate, but going forward RSC makes this separation unnecessary.\n\nSome noteworthy differences:\n\n- `<MDXRemote />` now accepts a `source` prop, instead of accepting the serialized output from `next-mdx-remote/serialize`\n- Custom components can no longer be provided by using the `MDXProvider` context from `@mdx-js/react`, as RSC does not support React Context\n- To access frontmatter outside of your MDX when passing `parseFrontmatter: true`, use the `compileMdx` method exposed from `next-mdx-remote/rsc`\n- The `lazy` prop is no longer supported, as the rendering happens on the server\n- `<MDXRemote />` must be rendered on the server, as it is now an async component. Client components can be rendered as part of the MDX markup\n\nFor more information on RSC, check out the [Next.js documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components).\n\n### Examples\n\n_Assuming usage in a Next.js 13+ application using the `app` directory._\n\n#### Basic\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n```\n\n#### Loading state\n\n```tsx\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    // Ideally this loading spinner would ensure there is no layout shift,\n    // this is an example for how to provide such a loading spinner.\n    // In Next.js you can also use `loading.js` for this.\n    <Suspense fallback={<>Loading...</>}>\n      <MDXRemote\n        source={`# Hello World\n\n        This is from Server Components!\n        `}\n      />\n    </Suspense>\n  )\n}\n```\n\n#### Custom Components\n\n```tsx\n// components/mdx-remote.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nconst components = {\n  h1: (props) => (\n    <h1 {...props} className=\"large-text\">\n      {props.children}\n    </h1>\n  ),\n}\n\nexport function CustomMDX(props) {\n  return (\n    <MDXRemote\n      {...props}\n      components={{ ...components, ...(props.components || {}) }}\n    />\n  )\n}\n```\n\n```tsx\n// app/page.js\nimport { CustomMDX } from '../components/mdx-remote'\n\nexport default function Home() {\n  return (\n    <CustomMDX\n      // h1 now renders with `large-text` className\n      source={`# Hello World\n      This is from Server Components!\n    `}\n    />\n  )\n}\n```\n\n#### Access Frontmatter outside of MDX\n\n```tsx\n// app/page.js\nimport { compileMDX } from 'next-mdx-remote/rsc'\n\nexport default async function Home() {\n  // Optionally provide a type for your frontmatter object\n  const { content, frontmatter } = await compileMDX<{ title: string }>({\n    source: `---\ntitle: RSC Frontmatter Example\n---\n# Hello World\nThis is from Server Components!\n`,\n    options: { parseFrontmatter: true },\n  })\n  return (\n    <>\n      <h1>{frontmatter.title}</h1>\n      {content}\n    </>\n  )\n}\n```\n\n## Alternatives\n\n`next-mdx-remote` is opinionated in what features it supports. If you need additional features not provided by `next-mdx-remote`, here are a few alternatives to consider:\n\n- [`mdx-bundler`](https://github.com/kentcdodds/mdx-bundler)\n- [`next-mdx-remote-client`](https://github.com/ipikuka/next-mdx-remote-client)\n- [`remote-mdx`](https://github.com/devjiwonchoi/remote-mdx)\n\n### You Might Not Need `next-mdx-remote`\n\nIf you're using React Server Components and just trying to use basic MDX with custom components, you don't need anything other than the core MDX library.\n\n```js\nimport { compile, run } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `# Hello, world!\n<ClientComponent />\n`\n\nexport default async function Page() {\n  // Compile the MDX source code to a function body\n  const code = String(\n    await compile(mdxSource, { outputFormat: 'function-body' })\n  )\n  // You can then either run the code on the server, generating a server\n  // component, or you can pass the string to a client component for\n  // final rendering.\n\n  // Run the compiled code with the runtime and get the default export\n  const { default: MDXContent } = await run(code, {\n    ...runtime,\n    baseUrl: import.meta.url,\n  })\n\n  // Render the MDX content, supplying the ClientComponent as a component\n  return <MDXContent components={{ ClientComponent }} />\n}\n```\n\nYou can also simplify this approach with `evaluate`, which compiles and runs code in a single call if you don't plan on passing the compiled string to a database or client component.\n\n```js\nimport { evaluate } from '@mdx-js/mdx'\nimport * as runtime from 'react/jsx-runtime'\nimport ClientComponent from './components/client'\n\n// MDX can be retrieved from anywhere, such as a file or a database.\nconst mdxSource = `\nexport const title = \"MDX Export Demo\";\n\n# Hello, world!\n<ClientComponent />\n\nexport function MDXDefinedComponent() {\n  return <p>MDX-defined component</p>;\n}\n`\n\nexport default async function Page() {\n  // Run the compiled code\n  const {\n    default: MDXContent,\n    MDXDefinedComponent,\n    ...rest\n  } = await evaluate(mdxSource, runtime)\n\n  console.log(rest) // logs { title: 'MDX Export Demo' }\n\n  // Render the MDX content, supplying the ClientComponent as a component, and\n  // the exported MDXDefinedComponent.\n  return (\n    <>\n      <MDXContent components={{ ClientComponent }} />\n      <MDXDefinedComponent />\n    </>\n  )\n}\n```\n\n## License\n\n[Mozilla Public License Version 2.0](./LICENSE)\n","readmeFilename":"README.md","users":{"klimy":true}}